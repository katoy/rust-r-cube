/Users/katoy/github/study-rust/2x2/src/cube.rs:
    1|       |/// キューブの面を表す列挙型
    2|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    3|       |pub enum Face {
    4|       |    Up,
    5|       |    Down,
    6|       |    Left,
    7|       |    Right,
    8|       |    Front,
    9|       |    Back,
   10|       |}
   11|       |
   12|       |/// ステッカーの色
   13|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
   14|       |pub enum Color {
   15|       |    White,
   16|       |    Yellow,
   17|       |    Green,
   18|       |    Blue,
   19|       |    Red,
   20|       |    Orange,
   21|       |}
   22|       |
   23|       |/// ステッカー（色と向き情報を持つ）
   24|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
   25|       |pub struct Sticker {
   26|       |    pub color: Color,
   27|       |    /// 向き（0-3の値で、90度単位の回転を表す）
   28|       |    pub orientation: u8,
   29|       |}
   30|       |
   31|       |impl Sticker {
   32|  1.70k|    pub fn new(color: Color) -> Self {
   33|  1.70k|        Self {
   34|  1.70k|            color,
   35|  1.70k|            orientation: 0,
   36|  1.70k|        }
   37|  1.70k|    }
   38|       |
   39|       |    /// 時計回りに90度回転
   40|  45.8M|    pub fn rotate_cw(&mut self) {
   41|  45.8M|        self.orientation = (self.orientation + 1) % 4;
   42|  45.8M|    }
   43|       |
   44|       |    /// 反時計回りに90度回転
   45|  53.2M|    pub fn rotate_ccw(&mut self) {
   46|  53.2M|        self.orientation = (self.orientation + 3) % 4;
   47|  53.2M|    }
   48|       |}
   49|       |
   50|       |/// 回転操作
   51|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
   52|       |pub enum Move {
   53|       |    R,  // Right face clockwise
   54|       |    Rp, // Right face counter-clockwise
   55|       |    L,  // Left face clockwise
   56|       |    Lp, // Left face counter-clockwise
   57|       |    U,  // Up face clockwise
   58|       |    Up, // Up face counter-clockwise
   59|       |    D,  // Down face clockwise
   60|       |    Dp, // Down face counter-clockwise
   61|       |    F,  // Front face clockwise
   62|       |    Fp, // Front face counter-clockwise
   63|       |    B,  // Back face clockwise
   64|       |    Bp, // Back face counter-clockwise
   65|       |}
   66|       |
   67|       |impl Move {
   68|       |    /// すべての回転操作を取得
   69|  1.04M|    pub fn all_moves() -> Vec<Move> {
   70|  1.04M|        vec![
   71|  1.04M|            Move::R,
   72|  1.04M|            Move::Rp,
   73|  1.04M|            Move::L,
   74|  1.04M|            Move::Lp,
   75|  1.04M|            Move::U,
   76|  1.04M|            Move::Up,
   77|  1.04M|            Move::D,
   78|  1.04M|            Move::Dp,
   79|  1.04M|            Move::F,
   80|  1.04M|            Move::Fp,
   81|  1.04M|            Move::B,
   82|  1.04M|            Move::Bp,
   83|       |        ]
   84|  1.04M|    }
   85|       |
   86|       |    /// 逆操作を取得
   87|  12.4M|    pub fn inverse(self) -> Move {
   88|  12.4M|        match self {
   89|  1.04M|            Move::R => Move::Rp,
   90|  1.04M|            Move::Rp => Move::R,
   91|  1.04M|            Move::L => Move::Lp,
   92|  1.04M|            Move::Lp => Move::L,
   93|  1.04M|            Move::U => Move::Up,
   94|  1.04M|            Move::Up => Move::U,
   95|  1.04M|            Move::D => Move::Dp,
   96|  1.04M|            Move::Dp => Move::D,
   97|  1.04M|            Move::F => Move::Fp,
   98|  1.04M|            Move::Fp => Move::F,
   99|  1.04M|            Move::B => Move::Bp,
  100|  1.04M|            Move::Bp => Move::B,
  101|       |        }
  102|  12.4M|    }
  103|       |}
  104|       |
  105|       |impl std::fmt::Display for Move {
  106|     12|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  107|     12|        let s = match self {
  108|      1|            Move::R => "R",
  109|      1|            Move::Rp => "R'",
  110|      1|            Move::L => "L",
  111|      1|            Move::Lp => "L'",
  112|      1|            Move::U => "U",
  113|      1|            Move::Up => "U'",
  114|      1|            Move::D => "D",
  115|      1|            Move::Dp => "D'",
  116|      1|            Move::F => "F",
  117|      1|            Move::Fp => "F'",
  118|      1|            Move::B => "B",
  119|      1|            Move::Bp => "B'",
  120|       |        };
  121|     12|        write!(f, "{}", s)
  122|     12|    }
  123|       |}
  124|       |
  125|       |/// 2x2 ルービックキューブ
  126|       |#[derive(Debug, Clone, PartialEq, Eq, Hash)]
  127|       |pub struct Cube {
  128|       |    /// 各面のステッカー（各面4つ）
  129|       |    /// インデックス: 0-3 (Up), 4-7 (Down), 8-11 (Left), 12-15 (Right), 16-19 (Front), 20-23 (Back)
  130|       |    stickers: [Sticker; 24],
  131|       |}
  132|       |
  133|       |impl Cube {
  134|       |    /// 完成状態のキューブを作成
  135|     68|    pub fn new() -> Self {
  136|     68|        let mut stickers = [Sticker::new(Color::White); 24];
  137|       |
  138|       |        // Up face (White)
  139|    272|        for sticker in stickers.iter_mut().take(4) {
                                     ^68      ^68        ^68
  140|    272|            *sticker = Sticker::new(Color::White);
  141|    272|        }
  142|       |        // Down face (Yellow)
  143|    272|        for sticker in stickers.iter_mut().take(8).skip(4) {
                                     ^68      ^68        ^68     ^68
  144|    272|            *sticker = Sticker::new(Color::Yellow);
  145|    272|        }
  146|       |        // Left face (Green)
  147|    272|        for sticker in stickers.iter_mut().take(12).skip(8) {
                                     ^68      ^68        ^68      ^68
  148|    272|            *sticker = Sticker::new(Color::Green);
  149|    272|        }
  150|       |        // Right face (Blue)
  151|    272|        for sticker in stickers.iter_mut().take(16).skip(12) {
                                     ^68      ^68        ^68      ^68
  152|    272|            *sticker = Sticker::new(Color::Blue);
  153|    272|        }
  154|       |        // Front face (Red)
  155|    272|        for sticker in stickers.iter_mut().take(20).skip(16) {
                                     ^68      ^68        ^68      ^68
  156|    272|            *sticker = Sticker::new(Color::Red);
  157|    272|        }
  158|       |        // Back face (Orange)
  159|    272|        for sticker in stickers.iter_mut().skip(20) {
                                     ^68      ^68        ^68
  160|    272|            *sticker = Sticker::new(Color::Orange);
  161|    272|        }
  162|       |
  163|     68|        Self { stickers }
  164|     68|    }
  165|       |
  166|       |    /// キューブが完成しているか判定
  167|     62|    pub fn is_solved(&self) -> bool {
  168|    252|        for face_start in (0..24).step_by(4) {
                                        ^62     ^62
  169|    252|            let first_color = self.stickers[face_start].color;
  170|    941|            for i in 1..4 {
                              ^715
  171|    715|                if self.stickers[face_start + i].color != first_color {
  172|     26|                    return false;
  173|    689|                }
  174|       |            }
  175|       |        }
  176|     36|        true
  177|     62|    }
  178|       |
  179|       |    /// ステッカーを取得
  180|    100|    pub fn get_sticker(&self, index: usize) -> Sticker {
  181|    100|        self.stickers[index]
  182|    100|    }
  183|       |
  184|       |    /// 回転操作を実行
  185|  11.4M|    pub fn apply_move(&mut self, mv: Move) {
  186|  11.4M|        match mv {
  187|   967k|            Move::R => self.rotate_r(),
  188|   959k|            Move::Rp => self.rotate_rp(),
  189|   950k|            Move::L => self.rotate_l(),
  190|   940k|            Move::Lp => self.rotate_lp(),
  191|   968k|            Move::U => self.rotate_u(),
  192|   960k|            Move::Up => self.rotate_up(),
  193|   953k|            Move::D => self.rotate_d(),
  194|   944k|            Move::Dp => self.rotate_dp(),
  195|   967k|            Move::F => self.rotate_f(),
  196|   959k|            Move::Fp => self.rotate_fp(),
  197|   942k|            Move::B => self.rotate_b(),
  198|   940k|            Move::Bp => self.rotate_bp(),
  199|       |        }
  200|  11.4M|    }
  201|       |
  202|       |    /// 面を時計回りに90度回転（内部ヘルパー）
  203|  5.74M|    fn rotate_face_cw(&mut self, face_start: usize) {
  204|  5.74M|        let temp = self.stickers[face_start];
  205|  5.74M|        self.stickers[face_start] = self.stickers[face_start + 2];
  206|  5.74M|        self.stickers[face_start + 2] = self.stickers[face_start + 3];
  207|  5.74M|        self.stickers[face_start + 3] = self.stickers[face_start + 1];
  208|  5.74M|        self.stickers[face_start + 1] = temp;
  209|       |
  210|       |        // 面上のステッカーの向きを更新
  211|  28.7M|        for i in 0..4 {
                          ^22.9M
  212|  22.9M|            self.stickers[face_start + i].rotate_cw();
  213|  22.9M|        }
  214|  5.74M|    }
  215|       |
  216|       |    /// 面を反時計回りに90度回転（内部ヘルパー）
  217|  5.70M|    fn rotate_face_ccw(&mut self, face_start: usize) {
  218|  5.70M|        let temp = self.stickers[face_start];
  219|  5.70M|        self.stickers[face_start] = self.stickers[face_start + 1];
  220|  5.70M|        self.stickers[face_start + 1] = self.stickers[face_start + 3];
  221|  5.70M|        self.stickers[face_start + 3] = self.stickers[face_start + 2];
  222|  5.70M|        self.stickers[face_start + 2] = temp;
  223|       |
  224|       |        // 面上のステッカーの向きを更新
  225|  28.5M|        for i in 0..4 {
                          ^22.8M
  226|  22.8M|            self.stickers[face_start + i].rotate_ccw();
  227|  22.8M|        }
  228|  5.70M|    }
  229|       |
  230|       |    /// R面を時計回りに回転
  231|   967k|    fn rotate_r(&mut self) {
  232|   967k|        self.rotate_face_cw(12); // Right face
  233|       |
  234|   967k|        let mut temp0 = self.stickers[1];
  235|   967k|        temp0.rotate_cw();
  236|   967k|        let mut temp1 = self.stickers[3];
  237|   967k|        temp1.rotate_cw();
  238|       |
  239|   967k|        self.stickers[1] = self.stickers[17];
  240|   967k|        self.stickers[1].rotate_cw();
  241|   967k|        self.stickers[3] = self.stickers[19];
  242|   967k|        self.stickers[3].rotate_cw();
  243|       |
  244|   967k|        self.stickers[17] = self.stickers[5];
  245|   967k|        self.stickers[17].rotate_cw();
  246|   967k|        self.stickers[19] = self.stickers[7];
  247|   967k|        self.stickers[19].rotate_cw();
  248|       |
  249|   967k|        self.stickers[5] = self.stickers[22];
  250|   967k|        self.stickers[5].rotate_cw();
  251|   967k|        self.stickers[7] = self.stickers[20];
  252|   967k|        self.stickers[7].rotate_cw();
  253|       |
  254|   967k|        self.stickers[22] = temp0;
  255|   967k|        self.stickers[20] = temp1;
  256|   967k|    }
  257|       |
  258|       |    /// R面を反時計回りに回転
  259|   959k|    fn rotate_rp(&mut self) {
  260|   959k|        self.rotate_face_ccw(12); // Right face
  261|       |
  262|   959k|        let mut temp0 = self.stickers[1];
  263|   959k|        temp0.rotate_ccw();
  264|   959k|        let mut temp1 = self.stickers[3];
  265|   959k|        temp1.rotate_ccw();
  266|       |
  267|   959k|        self.stickers[1] = self.stickers[22];
  268|   959k|        self.stickers[1].rotate_ccw();
  269|   959k|        self.stickers[3] = self.stickers[20];
  270|   959k|        self.stickers[3].rotate_ccw();
  271|       |
  272|   959k|        self.stickers[22] = self.stickers[5];
  273|   959k|        self.stickers[22].rotate_ccw();
  274|   959k|        self.stickers[20] = self.stickers[7];
  275|   959k|        self.stickers[20].rotate_ccw();
  276|       |
  277|   959k|        self.stickers[5] = self.stickers[17];
  278|   959k|        self.stickers[5].rotate_ccw();
  279|   959k|        self.stickers[7] = self.stickers[19];
  280|   959k|        self.stickers[7].rotate_ccw();
  281|       |
  282|   959k|        self.stickers[17] = temp0;
  283|   959k|        self.stickers[19] = temp1;
  284|   959k|    }
  285|       |
  286|       |    /// L面を時計回りに回転
  287|   950k|    fn rotate_l(&mut self) {
  288|   950k|        self.rotate_face_cw(8); // Left face
  289|       |
  290|   950k|        let mut temp0 = self.stickers[0];
  291|   950k|        temp0.rotate_cw();
  292|   950k|        let mut temp1 = self.stickers[2];
  293|   950k|        temp1.rotate_cw();
  294|       |
  295|   950k|        self.stickers[0] = self.stickers[21];
  296|   950k|        self.stickers[0].rotate_cw();
  297|   950k|        self.stickers[2] = self.stickers[23];
  298|   950k|        self.stickers[2].rotate_cw();
  299|       |
  300|   950k|        self.stickers[21] = self.stickers[4];
  301|   950k|        self.stickers[21].rotate_cw();
  302|   950k|        self.stickers[23] = self.stickers[6];
  303|   950k|        self.stickers[23].rotate_cw();
  304|       |
  305|   950k|        self.stickers[4] = self.stickers[16];
  306|   950k|        self.stickers[4].rotate_cw();
  307|   950k|        self.stickers[6] = self.stickers[18];
  308|   950k|        self.stickers[6].rotate_cw();
  309|       |
  310|   950k|        self.stickers[16] = temp0;
  311|   950k|        self.stickers[18] = temp1;
  312|   950k|    }
  313|       |
  314|       |    /// L面を反時計回りに回転
  315|   940k|    fn rotate_lp(&mut self) {
  316|   940k|        self.rotate_face_ccw(8); // Left face
  317|       |
  318|   940k|        let mut temp0 = self.stickers[0];
  319|   940k|        temp0.rotate_ccw();
  320|   940k|        let mut temp1 = self.stickers[2];
  321|   940k|        temp1.rotate_ccw();
  322|       |
  323|   940k|        self.stickers[0] = self.stickers[16];
  324|   940k|        self.stickers[0].rotate_ccw();
  325|   940k|        self.stickers[2] = self.stickers[18];
  326|   940k|        self.stickers[2].rotate_ccw();
  327|       |
  328|   940k|        self.stickers[16] = self.stickers[4];
  329|   940k|        self.stickers[16].rotate_ccw();
  330|   940k|        self.stickers[18] = self.stickers[6];
  331|   940k|        self.stickers[18].rotate_ccw();
  332|       |
  333|   940k|        self.stickers[4] = self.stickers[21];
  334|   940k|        self.stickers[4].rotate_ccw();
  335|   940k|        self.stickers[6] = self.stickers[23];
  336|   940k|        self.stickers[6].rotate_ccw();
  337|       |
  338|   940k|        self.stickers[21] = temp0;
  339|   940k|        self.stickers[23] = temp1;
  340|   940k|    }
  341|       |
  342|       |    /// U面を時計回りに回転
  343|   968k|    fn rotate_u(&mut self) {
  344|   968k|        self.rotate_face_cw(0); // Up face
  345|       |
  346|   968k|        let temp0 = self.stickers[16];
  347|   968k|        let temp1 = self.stickers[17];
  348|       |
  349|   968k|        self.stickers[16] = self.stickers[12];
  350|   968k|        self.stickers[17] = self.stickers[13];
  351|       |
  352|   968k|        self.stickers[12] = self.stickers[20];
  353|   968k|        self.stickers[13] = self.stickers[21];
  354|       |
  355|   968k|        self.stickers[20] = self.stickers[8];
  356|   968k|        self.stickers[21] = self.stickers[9];
  357|       |
  358|   968k|        self.stickers[8] = temp0;
  359|   968k|        self.stickers[9] = temp1;
  360|   968k|    }
  361|       |
  362|       |    /// U面を反時計回りに回転
  363|   960k|    fn rotate_up(&mut self) {
  364|   960k|        self.rotate_face_ccw(0); // Up face
  365|       |
  366|   960k|        let temp0 = self.stickers[16];
  367|   960k|        let temp1 = self.stickers[17];
  368|       |
  369|   960k|        self.stickers[16] = self.stickers[8];
  370|   960k|        self.stickers[17] = self.stickers[9];
  371|       |
  372|   960k|        self.stickers[8] = self.stickers[20];
  373|   960k|        self.stickers[9] = self.stickers[21];
  374|       |
  375|   960k|        self.stickers[20] = self.stickers[12];
  376|   960k|        self.stickers[21] = self.stickers[13];
  377|       |
  378|   960k|        self.stickers[12] = temp0;
  379|   960k|        self.stickers[13] = temp1;
  380|   960k|    }
  381|       |
  382|       |    /// D面を時計回りに回転
  383|   953k|    fn rotate_d(&mut self) {
  384|   953k|        self.rotate_face_cw(4); // Down face
  385|       |
  386|   953k|        let temp0 = self.stickers[18];
  387|   953k|        let temp1 = self.stickers[19];
  388|       |
  389|   953k|        self.stickers[18] = self.stickers[10];
  390|   953k|        self.stickers[19] = self.stickers[11];
  391|       |
  392|   953k|        self.stickers[10] = self.stickers[22];
  393|   953k|        self.stickers[11] = self.stickers[23];
  394|       |
  395|   953k|        self.stickers[22] = self.stickers[14];
  396|   953k|        self.stickers[23] = self.stickers[15];
  397|       |
  398|   953k|        self.stickers[14] = temp0;
  399|   953k|        self.stickers[15] = temp1;
  400|   953k|    }
  401|       |
  402|       |    /// D面を反時計回りに回転
  403|   944k|    fn rotate_dp(&mut self) {
  404|   944k|        self.rotate_face_ccw(4); // Down face
  405|       |
  406|   944k|        let temp0 = self.stickers[18];
  407|   944k|        let temp1 = self.stickers[19];
  408|       |
  409|   944k|        self.stickers[18] = self.stickers[14];
  410|   944k|        self.stickers[19] = self.stickers[15];
  411|       |
  412|   944k|        self.stickers[14] = self.stickers[22];
  413|   944k|        self.stickers[15] = self.stickers[23];
  414|       |
  415|   944k|        self.stickers[22] = self.stickers[10];
  416|   944k|        self.stickers[23] = self.stickers[11];
  417|       |
  418|   944k|        self.stickers[10] = temp0;
  419|   944k|        self.stickers[11] = temp1;
  420|   944k|    }
  421|       |
  422|       |    /// F面を時計回りに回転
  423|   967k|    fn rotate_f(&mut self) {
  424|   967k|        self.rotate_face_cw(16); // Front face
  425|       |
  426|   967k|        let temp0 = self.stickers[2];
  427|   967k|        let temp1 = self.stickers[3];
  428|       |
  429|   967k|        self.stickers[2] = self.stickers[11];
  430|   967k|        self.stickers[3] = self.stickers[9];
  431|       |
  432|   967k|        self.stickers[11] = self.stickers[4];
  433|   967k|        self.stickers[9] = self.stickers[5];
  434|       |
  435|   967k|        self.stickers[4] = self.stickers[12];
  436|   967k|        self.stickers[5] = self.stickers[14];
  437|       |
  438|   967k|        self.stickers[12] = temp0;
  439|   967k|        self.stickers[14] = temp1;
  440|   967k|    }
  441|       |
  442|       |    /// F面を反時計回りに回転
  443|   959k|    fn rotate_fp(&mut self) {
  444|   959k|        self.rotate_face_ccw(16); // Front face
  445|       |
  446|   959k|        let mut temp0 = self.stickers[2];
  447|   959k|        temp0.rotate_ccw();
  448|   959k|        let mut temp1 = self.stickers[3];
  449|   959k|        temp1.rotate_ccw();
  450|       |
  451|   959k|        self.stickers[2] = self.stickers[12];
  452|   959k|        self.stickers[2].rotate_ccw();
  453|   959k|        self.stickers[3] = self.stickers[14];
  454|   959k|        self.stickers[3].rotate_ccw();
  455|       |
  456|   959k|        self.stickers[12] = self.stickers[4];
  457|   959k|        self.stickers[12].rotate_ccw();
  458|   959k|        self.stickers[14] = self.stickers[5];
  459|   959k|        self.stickers[14].rotate_ccw();
  460|       |
  461|   959k|        self.stickers[4] = self.stickers[11];
  462|   959k|        self.stickers[4].rotate_ccw();
  463|   959k|        self.stickers[5] = self.stickers[9];
  464|   959k|        self.stickers[5].rotate_ccw();
  465|       |
  466|   959k|        self.stickers[11] = temp0;
  467|   959k|        self.stickers[9] = temp1;
  468|   959k|    }
  469|       |
  470|       |    /// B面を時計回りに回転
  471|   942k|    fn rotate_b(&mut self) {
  472|   942k|        self.rotate_face_cw(20); // Back face
  473|       |
  474|   942k|        let mut temp0 = self.stickers[0];
  475|   942k|        temp0.rotate_cw();
  476|   942k|        let mut temp1 = self.stickers[1];
  477|   942k|        temp1.rotate_cw();
  478|       |
  479|   942k|        self.stickers[0] = self.stickers[13];
  480|   942k|        self.stickers[0].rotate_cw();
  481|   942k|        self.stickers[1] = self.stickers[15];
  482|   942k|        self.stickers[1].rotate_cw();
  483|       |
  484|   942k|        self.stickers[13] = self.stickers[6];
  485|   942k|        self.stickers[13].rotate_cw();
  486|   942k|        self.stickers[15] = self.stickers[7];
  487|   942k|        self.stickers[15].rotate_cw();
  488|       |
  489|   942k|        self.stickers[6] = self.stickers[10];
  490|   942k|        self.stickers[6].rotate_cw();
  491|   942k|        self.stickers[7] = self.stickers[8];
  492|   942k|        self.stickers[7].rotate_cw();
  493|       |
  494|   942k|        self.stickers[10] = temp0;
  495|   942k|        self.stickers[8] = temp1;
  496|   942k|    }
  497|       |
  498|       |    /// B面を反時計回りに回転
  499|   940k|    fn rotate_bp(&mut self) {
  500|   940k|        self.rotate_face_ccw(20); // Back face
  501|       |
  502|   940k|        let mut temp0 = self.stickers[0];
  503|   940k|        temp0.rotate_ccw();
  504|   940k|        let mut temp1 = self.stickers[1];
  505|   940k|        temp1.rotate_ccw();
  506|       |
  507|   940k|        self.stickers[0] = self.stickers[10];
  508|   940k|        self.stickers[0].rotate_ccw();
  509|   940k|        self.stickers[1] = self.stickers[8];
  510|   940k|        self.stickers[1].rotate_ccw();
  511|       |
  512|   940k|        self.stickers[10] = self.stickers[7];
  513|   940k|        self.stickers[10].rotate_ccw();
  514|   940k|        self.stickers[8] = self.stickers[6];
  515|   940k|        self.stickers[8].rotate_ccw();
  516|       |
  517|   940k|        self.stickers[7] = self.stickers[13];
  518|   940k|        self.stickers[7].rotate_ccw();
  519|   940k|        self.stickers[6] = self.stickers[15];
  520|   940k|        self.stickers[6].rotate_ccw();
  521|       |
  522|   940k|        self.stickers[13] = temp0;
  523|   940k|        self.stickers[15] = temp1;
  524|   940k|    }
  525|       |
  526|       |    /// ランダムなスクランブルを生成
  527|      7|    pub fn scramble(&mut self, moves: usize) {
  528|       |        use rand::Rng;
  529|      7|        let mut rng = rand::thread_rng();
  530|      7|        let all_moves = Move::all_moves();
  531|       |
  532|     40|        for _ in 0..moves {
                                  ^7
  533|     40|            let mv = all_moves[rng.gen_range(0..all_moves.len())];
  534|     40|            self.apply_move(mv);
  535|     40|        }
  536|      7|    }
  537|       |
  538|       |    /// 色情報のみ比較するために、向き情報をリセットしたCubeを返す
  539|  11.4M|    pub fn normalized(&self) -> Self {
  540|  11.4M|        let mut new_cube = self.clone();
  541|   286M|        for sticker in &mut new_cube.stickers {
                          ^274M
  542|   274M|            sticker.orientation = 0;
  543|   274M|        }
  544|  11.4M|        new_cube
  545|  11.4M|    }
  546|       |}
  547|       |
  548|       |impl Default for Cube {
  549|      1|    fn default() -> Self {
  550|      1|        Self::new()
  551|      1|    }
  552|       |}

/Users/katoy/github/study-rust/2x2/src/gui/app.rs:
    1|       |use crate::cube::{Cube, Move};
    2|       |use crate::gui::renderer_3d::{draw_cube_3d, View3D};
    3|       |use crate::solver;
    4|       |use std::sync::mpsc::{channel, Receiver};
    5|       |use std::thread;
    6|       |use std::time::Instant;
    7|       |
    8|       |/// 表示モード
    9|       |#[derive(Debug, PartialEq, Eq, Clone, Copy)]
   10|       |pub enum ViewMode {
   11|       |    TwoD,
   12|       |    ThreeD,
   13|       |    Both,
   14|       |}
   15|       |
   16|       |/// アニメーション状態
   17|       |#[derive(Debug, Clone)]
   18|       |pub struct AnimationState {
   19|       |    pub current_move: Move,
   20|       |    pub progress: f32, // 0.0 to 1.0
   21|       |    pub start_time: Instant,
   22|       |    pub duration: f32, // seconds
   23|       |}
   24|       |
   25|       |impl AnimationState {
   26|      0|    pub fn new(mv: Move, duration: f32) -> Self {
   27|      0|        Self {
   28|      0|            current_move: mv,
   29|      0|            progress: 0.0,
   30|      0|            start_time: Instant::now(),
   31|      0|            duration,
   32|      0|        }
   33|      0|    }
   34|       |
   35|      0|    pub fn update(&mut self) -> bool {
   36|      0|        if self.duration <= 0.001 {
   37|      0|            self.progress = 1.0;
   38|      0|            return true;
   39|      0|        }
   40|      0|        let elapsed = self.start_time.elapsed().as_secs_f32();
   41|      0|        self.progress = (elapsed / self.duration).min(1.0);
   42|      0|        self.progress >= 1.0
   43|      0|    }
   44|       |
   45|       |    /// イージング関数 (ease-in-out)
   46|      0|    pub fn eased_progress(&self) -> f32 {
   47|      0|        let t = self.progress;
   48|      0|        if t < 0.5 {
   49|      0|            2.0 * t * t
   50|       |        } else {
   51|      0|            -1.0 + (4.0 - 2.0 * t) * t
   52|       |        }
   53|      0|    }
   54|       |}
   55|       |
   56|       |/// メインアプリケーション
   57|       |pub struct CubeApp {
   58|       |    cube: Cube,
   59|       |    animation: Option<AnimationState>,
   60|       |    move_queue: Vec<Move>,
   61|       |    pub animation_speed: f32, // seconds per move
   62|       |    pub is_paused: bool,
   63|       |    pub solution: Option<Vec<Move>>,
   64|       |    solving: bool,
   65|       |    pub solution_text: String,
   66|       |
   67|       |    // 表示設定
   68|       |    pub view_mode: ViewMode,
   69|       |    pub view_3d: View3D,
   70|       |
   71|       |    // ソルバー通信用
   72|       |    solver_receiver: Option<Receiver<solver::Solution>>,
   73|       |
   74|       |    // 解法ステップ管理
   75|       |    pub solution_step: usize,
   76|       |    pub solution_cube_state: Option<Cube>,
   77|       |    // アニメーション完了後にsolution_stepを更新するための保留値 (+1 or -1)
   78|       |    pending_solution_update: Option<isize>,
   79|       |}
   80|       |
   81|       |impl Default for CubeApp {
   82|      0|    fn default() -> Self {
   83|      0|        Self {
   84|      0|            cube: Cube::new(),
   85|      0|            animation: None,
   86|      0|            move_queue: Vec::new(),
   87|      0|            animation_speed: 0.3,
   88|      0|            is_paused: false,
   89|      0|            solution: None,
   90|      0|            solving: false,
   91|      0|            solution_text: String::new(),
   92|      0|            view_mode: ViewMode::Both,
   93|      0|            view_3d: View3D::default(),
   94|      0|            solver_receiver: None,
   95|      0|            solution_step: 0,
   96|      0|            solution_cube_state: None,
   97|      0|            pending_solution_update: None,
   98|      0|        }
   99|      0|    }
  100|       |}
  101|       |
  102|       |impl CubeApp {
  103|      0|    pub fn new(cc: &eframe::CreationContext<'_>) -> Self {
  104|       |        // 日本語フォントを設定
  105|      0|        Self::setup_custom_fonts(&cc.egui_ctx);
  106|       |
  107|       |        // 必要に応じてフォントサイズを調整
  108|      0|        let mut style = (*cc.egui_ctx.style()).clone();
  109|      0|        style.text_styles.insert(
  110|      0|            egui::TextStyle::Body,
  111|      0|            egui::FontId::new(14.0, egui::FontFamily::Proportional),
  112|       |        );
  113|      0|        style.text_styles.insert(
  114|      0|            egui::TextStyle::Button,
  115|      0|            egui::FontId::new(14.0, egui::FontFamily::Proportional),
  116|       |        );
  117|      0|        style.text_styles.insert(
  118|      0|            egui::TextStyle::Heading,
  119|      0|            egui::FontId::new(18.0, egui::FontFamily::Proportional),
  120|       |        );
  121|      0|        cc.egui_ctx.set_style(style);
  122|       |
  123|      0|        Self::default()
  124|      0|    }
  125|       |
  126|       |    /// 回転操作をキューに追加
  127|      0|    pub fn queue_move(&mut self, mv: Move) {
  128|      0|        self.move_queue.push(mv);
  129|      0|    }
  130|       |
  131|       |    /// 複数の回転操作をキューに追加
  132|      0|    pub fn queue_moves(&mut self, moves: Vec<Move>) {
  133|      0|        self.move_queue.extend(moves);
  134|      0|    }
  135|       |
  136|       |    /// スクランブル
  137|      0|    pub fn scramble(&mut self) {
  138|      0|        self.cube = Cube::new();
  139|      0|        self.cube.scramble(10);
  140|      0|        self.solution = None;
  141|      0|        self.solution_text.clear();
  142|      0|        self.move_queue.clear();
  143|      0|        self.animation = None;
  144|      0|        self.pending_solution_update = None;
  145|      0|    }
  146|       |
  147|       |    /// リセット
  148|      0|    pub fn reset(&mut self) {
  149|      0|        self.cube = Cube::new();
  150|      0|        self.solution = None;
  151|      0|        self.solution_text.clear();
  152|      0|        self.move_queue.clear();
  153|      0|        self.animation = None;
  154|      0|        self.pending_solution_update = None;
  155|       |        // ソルバー実行中ならキャンセルできないが、結果を無視するようにフラグをクリアする
  156|      0|        self.solving = false;
  157|      0|        self.solver_receiver = None;
  158|      0|    }
  159|       |
  160|       |    /// ソルバー実行
  161|      0|    pub fn solve(&mut self) {
  162|      0|        if self.solving {
  163|      0|            return;
  164|      0|        }
  165|      0|        self.solving = true;
  166|      0|        self.solution_text = "探索中...".to_string();
  167|       |
  168|       |        // 解法開始時の状態を保存
  169|      0|        self.solution_cube_state = Some(self.cube.clone());
  170|      0|        self.solution_step = 0;
  171|       |
  172|      0|        let cube_clone = self.cube.clone();
  173|      0|        let (tx, rx) = channel();
  174|      0|        self.solver_receiver = Some(rx);
  175|       |
  176|      0|        thread::spawn(move || {
  177|      0|            println!("ソルバー開始: 深度11まで探索");
  178|      0|            let solution = solver::solve(&cube_clone, 11);
  179|      0|            println!(
  180|      0|                "ソルバー完了: 解が{}",
  181|      0|                if solution.found {
  182|      0|                    "見つかりました"
  183|       |                } else {
  184|      0|                    "見つかりませんでした"
  185|       |                }
  186|       |            );
  187|      0|            if solution.found {
  188|      0|                println!("解の手数: {}", solution.moves.len());
  189|      0|            }
  190|      0|            if let Err(e) = tx.send(solution) {
  191|      0|                eprintln!("ソルバー結果の送信に失敗しました: {:?}", e);
  192|      0|            }
  193|      0|        });
  194|      0|    }
  195|       |
  196|       |    /// アニメーション更新
  197|      0|    fn update_animation(&mut self) {
  198|      0|        if self.is_paused {
  199|      0|            return;
  200|      0|        }
  201|       |
  202|      0|        if let Some(ref mut anim) = self.animation {
  203|      0|            if anim.update() {
  204|       |                // アニメーション完了
  205|      0|                self.cube.apply_move(anim.current_move);
  206|      0|                self.animation = None;
  207|       |
  208|       |                // ソルーション再生中の場合、ステップ数を更新
  209|      0|                if let Some(delta) = self.pending_solution_update {
  210|      0|                    if delta > 0 {
  211|      0|                        self.solution_step += delta as usize;
  212|      0|                    } else if delta < 0 {
  213|      0|                        self.solution_step = self.solution_step.saturating_sub((-delta) as usize);
  214|      0|                    }
  215|      0|                    self.pending_solution_update = None;
  216|      0|                }
  217|      0|            }
  218|      0|        } else if let Some(mv) = self.move_queue.first().copied() {
  219|      0|            // 次の操作を開始
  220|      0|            self.move_queue.remove(0);
  221|      0|            self.animation = Some(AnimationState::new(mv, self.animation_speed));
  222|      0|        }
  223|      0|    }
  224|       |
  225|       |    /// ソルバーの結果を確認
  226|      0|    fn check_solver_result(&mut self) {
  227|      0|        if let Some(rx) = &self.solver_receiver {
  228|      0|            if let Ok(solution) = rx.try_recv() {
  229|      0|                self.solving = false;
  230|      0|                self.solver_receiver = None;
  231|       |
  232|      0|                if solution.found {
  233|      0|                    self.solution = Some(solution.moves.clone());
  234|      0|                    self.solution_text = format!("解法: {} 手", solution.moves.len());
  235|      0|                    self.solution_step = 0;
  236|      0|                    // 自動実行はしない（ステップ操作で手動実行）
  237|      0|                } else {
  238|      0|                    self.solution_text = "解が見つかりませんでした".to_string();
  239|      0|                }
  240|      0|            }
  241|      0|        }
  242|      0|    }
  243|       |
  244|       |    /// キューブの状態を取得
  245|      0|    pub fn cube(&self) -> &Cube {
  246|      0|        &self.cube
  247|      0|    }
  248|       |
  249|       |    /// アニメーション状態を取得
  250|      0|    pub fn animation(&self) -> Option<&AnimationState> {
  251|      0|        self.animation.as_ref()
  252|      0|    }
  253|       |
  254|       |    /// 解法の次のステップへ進む
  255|      0|    pub fn solution_step_forward(&mut self) {
  256|      0|        if self.animation.is_some() {
  257|      0|            return;
  258|      0|        }
  259|      0|        if let Some(solution) = &self.solution {
  260|      0|            if self.solution_step < solution.len() {
  261|      0|                let mv = solution[self.solution_step];
  262|      0|                self.animation = Some(AnimationState::new(mv, self.animation_speed));
  263|      0|                self.pending_solution_update = Some(1);
  264|      0|            }
  265|      0|        }
  266|      0|    }
  267|       |
  268|       |    /// 解法の前のステップへ戻る
  269|      0|    pub fn solution_step_backward(&mut self) {
  270|      0|        if self.animation.is_some() {
  271|      0|            return;
  272|      0|        }
  273|      0|        if let Some(solution) = &self.solution {
  274|      0|            if self.solution_step > 0 {
  275|      0|                let mv = solution[self.solution_step - 1];
  276|      0|                let inverse_mv = mv.inverse();
  277|      0|                self.animation = Some(AnimationState::new(inverse_mv, self.animation_speed));
  278|      0|                self.pending_solution_update = Some(-1);
  279|      0|            }
  280|      0|        }
  281|      0|    }
  282|       |
  283|       |    /// 解法の最初へ戻る
  284|      0|    pub fn solution_step_reset(&mut self) {
  285|      0|        if let Some(cube_state) = &self.solution_cube_state {
  286|      0|            self.cube = cube_state.clone();
  287|      0|            self.solution_step = 0;
  288|      0|        }
  289|      0|    }
  290|       |
  291|       |    /// 解法を最後まで実行
  292|      0|    pub fn solution_step_to_end(&mut self) {
  293|      0|        let len = self.solution.as_ref().map(|s| s.len()).unwrap_or(0);
  294|      0|        while self.solution_step < len {
  295|      0|            self.solution_step_forward();
  296|      0|        }
  297|      0|    }
  298|       |
  299|      0|    fn setup_custom_fonts(ctx: &egui::Context) {
  300|      0|        let mut fonts = egui::FontDefinitions::default();
  301|       |
  302|      0|        fonts.font_data.insert(
  303|      0|            "NotoSansCJKjp".to_owned(),
  304|      0|            egui::FontData::from_static(include_bytes!(
  305|       |                "../../assets/fonts/NotoSansCJKjp-Regular.otf"
  306|       |            )),
  307|       |        );
  308|       |
  309|      0|        fonts
  310|      0|            .families
  311|      0|            .entry(egui::FontFamily::Proportional)
  312|      0|            .or_default()
  313|      0|            .insert(0, "NotoSansCJKjp".to_owned());
  314|       |
  315|      0|        fonts
  316|      0|            .families
  317|      0|            .entry(egui::FontFamily::Monospace)
  318|      0|            .or_default()
  319|      0|            .insert(0, "NotoSansCJKjp".to_owned());
  320|       |
  321|      0|        ctx.set_fonts(fonts);
  322|      0|    }
  323|       |
  324|       |    /// 3Dビューの描画処理
  325|      0|    fn show_3d_view(&mut self, ui: &mut egui::Ui) {
  326|      0|        let available = ui.available_size();
  327|      0|        let size = available.x.min(available.y);
  328|       |        // 領域確保
  329|      0|        let (rect, response) = ui.allocate_exact_size(
  330|      0|            egui::vec2(available.x, size), // 横幅いっぱいに使う
  331|      0|            egui::Sense::drag(),
  332|      0|        );
  333|       |
  334|       |        // 3Dビュー操作
  335|      0|        if response.dragged() {
  336|      0|            let delta = response.drag_delta();
  337|      0|            self.view_3d.yaw += delta.x * 0.01;
  338|      0|            self.view_3d.pitch += delta.y * 0.01;
  339|      0|
  340|      0|            // Pitch制限
  341|      0|            self.view_3d.pitch = self.view_3d.pitch.clamp(
  342|      0|                -std::f32::consts::FRAC_PI_2 + 0.1,
  343|      0|                std::f32::consts::FRAC_PI_2 - 0.1,
  344|      0|            );
  345|      0|        }
  346|       |        // ズーム操作
  347|      0|        if response.hovered() {
  348|      0|            let zoom_delta = ui.input(|i| i.raw_scroll_delta.y);
  349|      0|            if zoom_delta != 0.0 {
  350|      0|                self.view_3d.scale *= if zoom_delta > 0.0 { 1.1 } else { 0.9 };
  351|      0|                self.view_3d.scale = self.view_3d.scale.clamp(0.5, 3.0);
  352|      0|            }
  353|      0|        }
  354|       |
  355|      0|        draw_cube_3d(ui, rect, &self.cube, self.animation.as_ref(), &self.view_3d);
  356|       |
  357|       |        // ヘルプテキストを描画
  358|      0|        let help_text = "ドラッグで回転、ホイールでズーム";
  359|      0|        let help_pos = rect.min + egui::vec2(10.0, 10.0);
  360|      0|        ui.painter().text(
  361|      0|            help_pos,
  362|       |            egui::Align2::LEFT_TOP,
  363|      0|            help_text,
  364|      0|            egui::FontId::proportional(12.0),
  365|      0|            egui::Color32::from_rgba_premultiplied(255, 255, 255, 200),
  366|       |        );
  367|      0|    }
  368|       |
  369|       |    /// 2Dビューの描画処理
  370|      0|    fn show_2d_view(&mut self, ui: &mut egui::Ui) {
  371|      0|        let available = ui.available_size();
  372|      0|        let size = available.x.min(available.y);
  373|       |
  374|      0|        let (rect, _response) =
  375|      0|            ui.allocate_exact_size(egui::vec2(available.x, size), egui::Sense::hover());
  376|       |
  377|      0|        crate::gui::renderer::draw_cube(ui, rect, &self.cube, self.animation.as_ref());
  378|      0|    }
  379|       |
  380|       |    /// キーボード入力を処理
  381|      0|    fn handle_input(&mut self, ctx: &egui::Context) {
  382|       |        // アニメーション中やソルブ中は入力を受け付けない（オプション）
  383|       |        // ここでは連打できるように許可するが、キューに追加される
  384|       |
  385|       |        // Shiftキーが押されているか確認
  386|      0|        let shift = ctx.input(|i| i.modifiers.shift);
  387|       |
  388|       |        // 各キーの処理
  389|      0|        let input = ctx.input(|i| {
  390|      0|            let mut moves = Vec::new();
  391|       |
  392|      0|            if i.key_pressed(egui::Key::R) {
  393|      0|                moves.push(if shift { Move::Rp } else { Move::R });
  394|      0|            }
  395|      0|            if i.key_pressed(egui::Key::L) {
  396|      0|                moves.push(if shift { Move::Lp } else { Move::L });
  397|      0|            }
  398|      0|            if i.key_pressed(egui::Key::U) {
  399|      0|                moves.push(if shift { Move::Up } else { Move::U });
  400|      0|            }
  401|      0|            if i.key_pressed(egui::Key::D) {
  402|      0|                moves.push(if shift { Move::Dp } else { Move::D });
  403|      0|            }
  404|      0|            if i.key_pressed(egui::Key::F) {
  405|      0|                moves.push(if shift { Move::Fp } else { Move::F });
  406|      0|            }
  407|      0|            if i.key_pressed(egui::Key::B) {
  408|      0|                moves.push(if shift { Move::Bp } else { Move::B });
  409|      0|            }
  410|      0|            moves
  411|      0|        });
  412|       |
  413|      0|        for mv in input {
  414|      0|            self.queue_move(mv);
  415|      0|        }
  416|       |
  417|       |        // 機能キー
  418|      0|        if ctx.input(|i| i.key_pressed(egui::Key::S)) {
  419|      0|            self.scramble();
  420|      0|        }
  421|      0|        if ctx.input(|i| i.key_pressed(egui::Key::Space)) && !self.solving {
  422|      0|            self.solve();
  423|      0|        }
  424|      0|        if ctx.input(|i| i.key_pressed(egui::Key::Escape)) {
  425|      0|            self.reset();
  426|      0|        }
  427|      0|    }
  428|       |}
  429|       |
  430|       |impl eframe::App for CubeApp {
  431|      0|    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
  432|       |        // ソルバーの結果を確認
  433|      0|        self.check_solver_result();
  434|       |
  435|       |        // キーボード入力処理
  436|      0|        self.handle_input(ctx);
  437|       |
  438|       |        // アニメーション更新
  439|      0|        self.update_animation();
  440|       |
  441|       |        // 継続的な再描画をリクエスト
  442|      0|        ctx.request_repaint();
  443|       |
  444|       |        // 右側のサイドパネル (コントロールパネル)
  445|      0|        egui::SidePanel::right("control_panel")
  446|      0|            .min_width(250.0)
  447|      0|            .default_width(250.0)
  448|      0|            .resizable(false)
  449|      0|            .show(ctx, |ui| {
  450|      0|                ui.vertical(|ui| {
  451|      0|                    ui.add_space(10.0);
  452|      0|                    crate::gui::controls::draw_controls(self, ui);
  453|      0|                });
  454|      0|            });
  455|       |
  456|       |        // 中央パネル (メインコンテンツ)
  457|      0|        egui::CentralPanel::default().show(ctx, |ui| {
  458|      0|            ui.horizontal(|ui| {
  459|      0|                ui.heading("2x2 ルービックキューブ");
  460|      0|                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
  461|      0|                    ui.selectable_value(&mut self.view_mode, ViewMode::Both, "2D & 3D");
  462|      0|                    ui.selectable_value(&mut self.view_mode, ViewMode::ThreeD, "3Dのみ");
  463|      0|                    ui.selectable_value(&mut self.view_mode, ViewMode::TwoD, "2Dのみ");
  464|      0|                });
  465|      0|            });
  466|      0|            ui.add_space(10.0);
  467|       |
  468|       |            // キューブ表示領域
  469|      0|            ui.group(|ui| {
  470|       |                // 利用可能なサイズを計算
  471|      0|                ui.set_min_width(300.0);
  472|      0|                ui.set_min_height(300.0);
  473|       |
  474|      0|                match self.view_mode {
  475|      0|                    ViewMode::TwoD => {
  476|      0|                        self.show_2d_view(ui);
  477|      0|                    }
  478|      0|                    ViewMode::ThreeD => {
  479|      0|                        self.show_3d_view(ui);
  480|      0|                    }
  481|       |                    ViewMode::Both => {
  482|      0|                        ui.columns(2, |columns| {
  483|      0|                            columns[0].vertical(|ui| {
  484|      0|                                ui.heading("3Dビュー");
  485|      0|                                self.show_3d_view(ui);
  486|      0|                            });
  487|      0|                            columns[1].vertical(|ui| {
  488|      0|                                ui.heading("展開図");
  489|      0|                                self.show_2d_view(ui);
  490|      0|                            });
  491|      0|                        });
  492|       |                    }
  493|       |                }
  494|      0|            });
  495|      0|        });
  496|      0|    }
  497|       |}

/Users/katoy/github/study-rust/2x2/src/gui/controls.rs:
    1|       |use crate::cube::Move;
    2|       |use crate::gui::app::CubeApp;
    3|       |
    4|       |/// コントロールパネルを描画
    5|      0|pub fn draw_controls(app: &mut CubeApp, ui: &mut egui::Ui) {
    6|      0|    ui.heading("操作");
    7|       |
    8|      0|    ui.add_space(10.0);
    9|       |
   10|       |    // 基本操作ボタン
   11|      0|    ui.label("基本操作:");
   12|      0|    ui.horizontal(|ui| {
   13|      0|        if ui.button("スクランブル").clicked() {
   14|      0|            app.scramble();
   15|      0|        }
   16|      0|        if ui.button("リセット").clicked() {
   17|      0|            app.reset();
   18|      0|        }
   19|      0|    });
   20|       |
   21|      0|    ui.add_space(10.0);
   22|       |
   23|       |    // 回転ボタン
   24|      0|    ui.label("回転操作:");
   25|       |
   26|      0|    ui.horizontal(|ui| {
   27|      0|        if ui.button("R").clicked() {
   28|      0|            app.queue_move(Move::R);
   29|      0|        }
   30|      0|        if ui.button("R'").clicked() {
   31|      0|            app.queue_move(Move::Rp);
   32|      0|        }
   33|      0|        if ui.button("L").clicked() {
   34|      0|            app.queue_move(Move::L);
   35|      0|        }
   36|      0|        if ui.button("L'").clicked() {
   37|      0|            app.queue_move(Move::Lp);
   38|      0|        }
   39|      0|    });
   40|       |
   41|      0|    ui.horizontal(|ui| {
   42|      0|        if ui.button("U").clicked() {
   43|      0|            app.queue_move(Move::U);
   44|      0|        }
   45|      0|        if ui.button("U'").clicked() {
   46|      0|            app.queue_move(Move::Up);
   47|      0|        }
   48|      0|        if ui.button("D").clicked() {
   49|      0|            app.queue_move(Move::D);
   50|      0|        }
   51|      0|        if ui.button("D'").clicked() {
   52|      0|            app.queue_move(Move::Dp);
   53|      0|        }
   54|      0|    });
   55|       |
   56|      0|    ui.horizontal(|ui| {
   57|      0|        if ui.button("F").clicked() {
   58|      0|            app.queue_move(Move::F);
   59|      0|        }
   60|      0|        if ui.button("F'").clicked() {
   61|      0|            app.queue_move(Move::Fp);
   62|      0|        }
   63|      0|        if ui.button("B").clicked() {
   64|      0|            app.queue_move(Move::B);
   65|      0|        }
   66|      0|        if ui.button("B'").clicked() {
   67|      0|            app.queue_move(Move::Bp);
   68|      0|        }
   69|      0|    });
   70|       |
   71|      0|    ui.add_space(10.0);
   72|       |
   73|       |    // アニメーション制御
   74|      0|    ui.label("アニメーション:");
   75|      0|    ui.horizontal(|ui| {
   76|      0|        ui.label("速度:");
   77|      0|        ui.add(egui::Slider::new(&mut app.animation_speed, 0.0..=5.0).text("秒"));
   78|      0|    });
   79|       |
   80|      0|    ui.horizontal(|ui| {
   81|      0|        if ui
   82|      0|            .button(if app.is_paused {
   83|      0|                "再開"
   84|       |            } else {
   85|      0|                "一時停止"
   86|       |            })
   87|      0|            .clicked()
   88|      0|        {
   89|      0|            app.is_paused = !app.is_paused;
   90|      0|        }
   91|      0|    });
   92|       |
   93|      0|    ui.add_space(10.0);
   94|       |
   95|       |    // ソルバー
   96|      0|    ui.label("ソルバー:");
   97|      0|    if ui.button("解法を探す").clicked() {
   98|      0|        app.solve();
   99|      0|    }
  100|       |
  101|      0|    if !app.solution_text.is_empty() {
  102|      0|        ui.add_space(5.0);
  103|      0|        ui.label(&app.solution_text);
  104|      0|    }
  105|       |
  106|       |    // 解法ステップ操作
  107|      0|    if app.solution.is_some() {
  108|      0|        let solution_len = app.solution.as_ref().unwrap().len();
  109|      0|        ui.add_space(10.0);
  110|      0|        ui.label("解法ステップ操作:");
  111|       |
  112|       |        // 現在のステップ表示
  113|      0|        ui.label(format!("ステップ: {}/{}", app.solution_step, solution_len));
  114|       |
  115|       |        // 現在のステップの動き表示
  116|      0|        if app.solution_step < solution_len {
  117|      0|            let next_move = app.solution.as_ref().unwrap()[app.solution_step];
  118|      0|            ui.label(format!("次の動き: {}", next_move));
  119|      0|        } else if app.solution_step == solution_len {
  120|      0|            ui.colored_label(egui::Color32::GREEN, "完了!");
  121|      0|        }
  122|       |
  123|      0|        ui.add_space(5.0);
  124|       |
  125|       |        // ステップ操作ボタン
  126|      0|        ui.horizontal(|ui| {
  127|      0|            if ui.button("⏮ 最初へ").clicked() {
  128|      0|                app.solution_step_reset();
  129|      0|            }
  130|       |
  131|      0|            ui.add_enabled_ui(app.solution_step > 0, |ui| {
  132|      0|                if ui.button("◀ 前へ").clicked() {
  133|      0|                    app.solution_step_backward();
  134|      0|                }
  135|      0|            });
  136|       |
  137|      0|            ui.add_enabled_ui(app.solution_step < solution_len, |ui| {
  138|      0|                if ui.button("次へ ▶").clicked() {
  139|      0|                    app.solution_step_forward();
  140|      0|                }
  141|      0|            });
  142|       |
  143|      0|            if ui.button("最後へ ⏭").clicked() {
  144|      0|                app.solution_step_to_end();
  145|      0|            }
  146|      0|        });
  147|       |
  148|      0|        ui.add_space(5.0);
  149|       |
  150|       |        // プログレスバー
  151|      0|        let progress = app.solution_step as f32 / solution_len as f32;
  152|      0|        ui.add(
  153|      0|            egui::ProgressBar::new(progress)
  154|      0|                .text(format!("{}/{}", app.solution_step, solution_len)),
  155|       |        );
  156|      0|    }
  157|       |
  158|      0|    ui.add_space(10.0);
  159|       |
  160|       |    // 状態表示
  161|      0|    if app.cube().is_solved() {
  162|      0|        ui.colored_label(egui::Color32::GREEN, "✓ 完成!");
  163|      0|    } else {
  164|      0|        ui.label("未完成");
  165|      0|    }
  166|      0|}

/Users/katoy/github/study-rust/2x2/src/gui/renderer.rs:
    1|       |use crate::cube::{Color, Cube, Move, Sticker};
    2|       |use crate::gui::app::AnimationState;
    3|       |use egui::{Color32, Painter, Pos2, Rect, Stroke, Vec2};
    4|       |
    5|       |/// ステッカーの色をegui Color32に変換
    6|      0|fn color_to_color32(color: Color) -> Color32 {
    7|      0|    match color {
    8|      0|        Color::White => Color32::from_rgb(255, 255, 255),
    9|      0|        Color::Yellow => Color32::from_rgb(255, 255, 0),
   10|      0|        Color::Green => Color32::from_rgb(0, 200, 0),
   11|      0|        Color::Blue => Color32::from_rgb(0, 100, 255),
   12|      0|        Color::Red => Color32::from_rgb(255, 50, 50),
   13|      0|        Color::Orange => Color32::from_rgb(255, 165, 0),
   14|       |    }
   15|      0|}
   16|       |
   17|       |/// ステッカーを描画
   18|      0|fn draw_sticker(
   19|      0|    painter: &Painter,
   20|      0|    center: Pos2,
   21|      0|    size: f32,
   22|      0|    sticker: Sticker,
   23|      0|    rotation_offset_deg: f32,
   24|      0|    alpha: f32,
   25|      0|) {
   26|       |    // ステッカーの背景を描画
   27|      0|    let rect = Rect::from_center_size(center, Vec2::splat(size * 0.95));
   28|       |
   29|       |    // 回転を適用した矩形を描画するために、頂点を計算して回転させる
   30|      0|    if rotation_offset_deg.abs() > 0.1 {
   31|      0|        let angle = rotation_offset_deg.to_radians();
   32|      0|        let cos = angle.cos();
   33|      0|        let sin = angle.sin();
   34|       |
   35|      0|        let half = size * 0.95 / 2.0;
   36|      0|        let corners = [
   37|      0|            Pos2::new(-half, -half),
   38|      0|            Pos2::new(half, -half),
   39|      0|            Pos2::new(half, half),
   40|      0|            Pos2::new(-half, half),
   41|      0|        ];
   42|       |
   43|      0|        let rotated_corners: Vec<Pos2> = corners
   44|      0|            .iter()
   45|      0|            .map(|p| {
   46|      0|                Pos2::new(
   47|      0|                    center.x + p.x * cos - p.y * sin,
   48|      0|                    center.y + p.x * sin + p.y * cos,
   49|       |                )
   50|      0|            })
   51|      0|            .collect();
   52|       |
   53|      0|        painter.add(egui::Shape::convex_polygon(
   54|      0|            rotated_corners.clone(),
   55|      0|            color_to_color32(sticker.color).linear_multiply(alpha),
   56|      0|            Stroke::new(2.0, Color32::BLACK.linear_multiply(alpha)),
   57|       |        ));
   58|      0|    } else {
   59|      0|        painter.rect_filled(
   60|      0|            rect,
   61|      0|            3.0,
   62|      0|            color_to_color32(sticker.color).linear_multiply(alpha),
   63|      0|        );
   64|      0|        painter.rect_stroke(
   65|      0|            rect,
   66|      0|            3.0,
   67|      0|            Stroke::new(2.0, Color32::BLACK.linear_multiply(alpha)),
   68|      0|        );
   69|      0|    }
   70|       |
   71|       |    // 矢印を描画（向きを示す）
   72|      0|    let arrow_rotation = (sticker.orientation as f32 * 90.0 + rotation_offset_deg).to_radians();
   73|      0|    draw_arrow(painter, center, size * 0.3, arrow_rotation, alpha);
   74|      0|}
   75|       |
   76|       |/// 矢印を描画
   77|      0|fn draw_arrow(painter: &Painter, center: Pos2, length: f32, rotation: f32, alpha: f32) {
   78|      0|    let cos = rotation.cos();
   79|      0|    let sin = rotation.sin();
   80|       |
   81|       |    // 矢印の先端
   82|      0|    let tip = Pos2::new(center.x + length * sin, center.y - length * cos);
   83|       |
   84|       |    // 矢印の根元
   85|      0|    let base = Pos2::new(center.x - length * 0.3 * sin, center.y + length * 0.3 * cos);
   86|       |
   87|       |    // 矢印の羽
   88|      0|    let wing_length = length * 0.4;
   89|      0|    let wing_angle = 30.0_f32.to_radians();
   90|       |
   91|      0|    let left_wing = Pos2::new(
   92|      0|        tip.x - wing_length * (rotation + wing_angle).sin(),
   93|      0|        tip.y + wing_length * (rotation + wing_angle).cos(),
   94|       |    );
   95|       |
   96|      0|    let right_wing = Pos2::new(
   97|      0|        tip.x - wing_length * (rotation - wing_angle).sin(),
   98|      0|        tip.y + wing_length * (rotation - wing_angle).cos(),
   99|       |    );
  100|       |
  101|       |    // 矢印を描画
  102|       |    // Color32::from_black_alpha(180) は alpha=180/255 相当。
  103|       |    // alpha引数を反映させるため、Color32::BLACK.linear_multiply(alpha)をベースに調整してもいいが、
  104|       |    // ここでは単純に linear_multiply を使う
  105|      0|    let stroke = Stroke::new(2.0, Color32::from_black_alpha(180).linear_multiply(alpha));
  106|      0|    painter.line_segment([base, tip], stroke);
  107|      0|    painter.line_segment([tip, left_wing], stroke);
  108|      0|    painter.line_segment([tip, right_wing], stroke);
  109|      0|}
  110|       |
  111|       |/// インデックスに対応するグリッド座標 (col, row) を取得
  112|      0|fn get_grid_coords(index: usize) -> Pos2 {
  113|      0|    let (col, row) = match index {
  114|      0|        0..=3 => (2.0 + (index % 2) as f32, 0.0 + (index / 2) as f32), // U
  115|      0|        4..=7 => (
  116|      0|            2.0 + ((index - 4) % 2) as f32,
  117|      0|            4.0 + ((index - 4) / 2) as f32,
  118|      0|        ), // D
  119|      0|        8..=11 => (
  120|      0|            0.0 + ((index - 8) % 2) as f32,
  121|      0|            2.0 + ((index - 8) / 2) as f32,
  122|      0|        ), // L
  123|      0|        12..=15 => (
  124|      0|            4.0 + ((index - 12) % 2) as f32,
  125|      0|            2.0 + ((index - 12) / 2) as f32,
  126|      0|        ), // R
  127|      0|        16..=19 => (
  128|      0|            2.0 + ((index - 16) % 2) as f32,
  129|      0|            2.0 + ((index - 16) / 2) as f32,
  130|      0|        ), // F
  131|      0|        20..=23 => (
  132|      0|            6.0 + ((index - 20) % 2) as f32,
  133|      0|            2.0 + ((index - 20) / 2) as f32,
  134|      0|        ), // B
  135|      0|        _ => (0.0, 0.0),
  136|       |    };
  137|      0|    Pos2::new(col, row)
  138|      0|}
  139|       |
  140|       |/// アニメーション情報の型エイリアス: (移動マッピング, 回転面情報)
  141|       |type AnimationInfo = (Vec<(usize, usize)>, Option<(usize, f32)>);
  142|       |
  143|       |/// アニメーション情報：移動マッピングと回転面情報
  144|      0|fn get_animation_info(mv: Move) -> AnimationInfo {
  145|      0|    let mapping = match mv {
  146|      0|        Move::U => vec![
  147|      0|            (16, 8),
  148|      0|            (17, 9),
  149|      0|            (8, 20),
  150|      0|            (9, 21),
  151|      0|            (20, 12),
  152|      0|            (21, 13),
  153|      0|            (12, 16),
  154|      0|            (13, 17),
  155|       |        ],
  156|      0|        Move::Up => vec![
  157|      0|            (8, 16),
  158|      0|            (9, 17),
  159|      0|            (20, 8),
  160|      0|            (21, 9),
  161|      0|            (12, 20),
  162|      0|            (13, 21),
  163|      0|            (16, 12),
  164|      0|            (17, 13),
  165|       |        ],
  166|      0|        Move::D => vec![
  167|      0|            (18, 14),
  168|      0|            (19, 15),
  169|      0|            (14, 22),
  170|      0|            (15, 23),
  171|      0|            (22, 10),
  172|      0|            (23, 11),
  173|      0|            (10, 18),
  174|      0|            (11, 19),
  175|       |        ],
  176|      0|        Move::Dp => vec![
  177|      0|            (14, 18),
  178|      0|            (15, 19),
  179|      0|            (22, 14),
  180|      0|            (23, 15),
  181|      0|            (10, 22),
  182|      0|            (11, 23),
  183|      0|            (18, 10),
  184|      0|            (19, 11),
  185|       |        ],
  186|      0|        Move::R => vec![
  187|      0|            (17, 1),
  188|      0|            (19, 3),
  189|      0|            (1, 22),
  190|      0|            (3, 20),
  191|      0|            (22, 5),
  192|      0|            (20, 7),
  193|      0|            (5, 17),
  194|      0|            (7, 19),
  195|       |        ],
  196|      0|        Move::Rp => vec![
  197|      0|            (1, 17),
  198|      0|            (3, 19),
  199|      0|            (22, 1),
  200|      0|            (20, 3),
  201|      0|            (5, 22),
  202|      0|            (7, 20),
  203|      0|            (17, 5),
  204|      0|            (19, 7),
  205|       |        ],
  206|      0|        Move::L => vec![
  207|      0|            (21, 0),
  208|      0|            (23, 2),
  209|      0|            (0, 16),
  210|      0|            (2, 18),
  211|      0|            (16, 4),
  212|      0|            (18, 6),
  213|      0|            (4, 21),
  214|      0|            (6, 23),
  215|       |        ],
  216|      0|        Move::Lp => vec![
  217|      0|            (0, 21),
  218|      0|            (2, 23),
  219|      0|            (16, 0),
  220|      0|            (18, 2),
  221|      0|            (4, 16),
  222|      0|            (6, 18),
  223|      0|            (21, 4),
  224|      0|            (23, 6),
  225|       |        ],
  226|      0|        Move::F => vec![
  227|      0|            (11, 2),
  228|      0|            (9, 3),
  229|      0|            (2, 12),
  230|      0|            (3, 14),
  231|      0|            (12, 4),
  232|      0|            (14, 5),
  233|      0|            (4, 11),
  234|      0|            (5, 9),
  235|       |        ],
  236|      0|        Move::Fp => vec![
  237|      0|            (2, 11),
  238|      0|            (3, 9),
  239|      0|            (12, 2),
  240|      0|            (14, 3),
  241|      0|            (4, 12),
  242|      0|            (5, 14),
  243|      0|            (11, 4),
  244|      0|            (9, 5),
  245|       |        ],
  246|      0|        Move::B => vec![
  247|      0|            (13, 0),
  248|      0|            (15, 1),
  249|      0|            (0, 10),
  250|      0|            (1, 8),
  251|      0|            (10, 6),
  252|      0|            (8, 7),
  253|      0|            (6, 13),
  254|      0|            (7, 15),
  255|       |        ],
  256|      0|        Move::Bp => vec![
  257|      0|            (0, 13),
  258|      0|            (1, 15),
  259|      0|            (10, 0),
  260|      0|            (8, 1),
  261|      0|            (6, 10),
  262|      0|            (7, 8),
  263|      0|            (13, 6),
  264|      0|            (15, 7),
  265|       |        ],
  266|       |    };
  267|       |
  268|      0|    let face_rotation = match mv {
  269|      0|        Move::U => Some((0, 90.0)),
  270|      0|        Move::Up => Some((0, -90.0)),
  271|      0|        Move::D => Some((4, 90.0)),
  272|      0|        Move::Dp => Some((4, -90.0)),
  273|      0|        Move::L => Some((8, 90.0)),
  274|      0|        Move::Lp => Some((8, -90.0)),
  275|      0|        Move::R => Some((12, 90.0)),
  276|      0|        Move::Rp => Some((12, -90.0)),
  277|      0|        Move::F => Some((16, 90.0)),
  278|      0|        Move::Fp => Some((16, -90.0)),
  279|      0|        Move::B => Some((20, 90.0)),
  280|      0|        Move::Bp => Some((20, -90.0)),
  281|       |    };
  282|       |
  283|      0|    (mapping, face_rotation)
  284|      0|}
  285|       |
  286|       |/// 点を回転させる
  287|      0|fn rotate_point(p: Pos2, center: Pos2, angle_degrees: f32) -> Pos2 {
  288|      0|    let angle = angle_degrees.to_radians();
  289|      0|    let cos = angle.cos();
  290|      0|    let sin = angle.sin();
  291|      0|    Pos2::new(
  292|      0|        center.x + (p.x - center.x) * cos - (p.y - center.y) * sin,
  293|      0|        center.y + (p.x - center.x) * sin + (p.y - center.y) * cos,
  294|       |    )
  295|      0|}
  296|       |
  297|       |/// キューブを展開図として描画
  298|      0|pub fn draw_cube(ui: &mut egui::Ui, rect: Rect, cube: &Cube, animation: Option<&AnimationState>) {
  299|      0|    let painter = ui.painter();
  300|       |
  301|      0|    let grid_cols = 8.0;
  302|      0|    let grid_rows = 6.0;
  303|       |
  304|       |    // グリッドサイズ計算
  305|      0|    let grid_size = (rect.width() / grid_cols).min(rect.height() / grid_rows) * 0.95;
  306|      0|    let sticker_size = grid_size * 0.85;
  307|       |
  308|      0|    let total_width = grid_size * grid_cols;
  309|      0|    let total_height = grid_size * grid_rows;
  310|       |
  311|      0|    let start_x = rect.left() + (rect.width() - total_width) / 2.0;
  312|      0|    let start_y = rect.top() + (rect.height() - total_height) / 2.0;
  313|      0|    let base_pos = Pos2::new(start_x + grid_size * 0.5, start_y + grid_size * 0.5);
  314|       |
  315|       |    // グリッド座標からスクリーン座標へ変換するクロージャ
  316|      0|    let to_screen = |grid_p: Pos2| -> Pos2 {
  317|      0|        Pos2::new(
  318|      0|            base_pos.x + grid_p.x * grid_size,
  319|      0|            base_pos.y + grid_p.y * grid_size,
  320|       |        )
  321|      0|    };
  322|       |
  323|      0|    let (anim_mapping, anim_face_rot) = if let Some(anim) = animation {
  324|      0|        get_animation_info(anim.current_move)
  325|       |    } else {
  326|      0|        (vec![], None)
  327|       |    };
  328|       |
  329|       |    // 全ステッカーを描画
  330|      0|    for i in 0..24 {
  331|      0|        let sticker = cube.get_sticker(i);
  332|      0|        let grid_pos = get_grid_coords(i);
  333|      0|        let mut rotation = 0.0;
  334|      0|        let mut screen_pos = to_screen(grid_pos);
  335|       |
  336|      0|        let mut drawn = false;
  337|       |
  338|      0|        if let Some(anim) = animation {
  339|       |            // 面回転の処理
  340|      0|            if let Some((face_start, angle)) = anim_face_rot {
  341|      0|                if i >= face_start && i < face_start + 4 {
  342|      0|                    // 面の中心
  343|      0|                    let center_grid_idx = face_start;
  344|      0|                    let center_grid_base = get_grid_coords(center_grid_idx);
  345|      0|                    // 2x2の中心は (col+0.5, row+0.5)
  346|      0|                    let center_grid = Pos2::new(center_grid_base.x + 0.5, center_grid_base.y + 0.5);
  347|      0|                    let center_screen = to_screen(center_grid);
  348|      0|
  349|      0|                    let current_angle = angle * anim.eased_progress();
  350|      0|                    screen_pos = rotate_point(screen_pos, center_screen, current_angle);
  351|      0|                    rotation = current_angle;
  352|      0|                }
  353|      0|            }
  354|       |
  355|       |            // 移動の処理
  356|      0|            if let Some((_, target_idx)) = anim_mapping.iter().find(|(src, _)| *src == i) {
  357|      0|                let target_grid_pos = get_grid_coords(*target_idx);
  358|       |
  359|       |                // ワープ回避：距離が遠すぎる場合はラップアラウンドアニメーション
  360|       |                // 閾値を3.0に設定（F回転の距離2.23は通常移動。裏側への移動など距離3.0以上のみワープ）
  361|      0|                if grid_pos.distance(target_grid_pos) < 3.0 {
  362|      0|                    let src_screen = screen_pos; // 回転なしの場合の初期位置
  363|      0|                    let dst_screen = to_screen(target_grid_pos);
  364|      0|
  365|      0|                    screen_pos = Pos2::new(
  366|      0|                        src_screen.x + (dst_screen.x - src_screen.x) * anim.eased_progress(),
  367|      0|                        src_screen.y + (dst_screen.y - src_screen.y) * anim.eased_progress(),
  368|      0|                    );
  369|      0|                } else {
  370|       |                    // ラップアラウンド
  371|      0|                    let diff = target_grid_pos - grid_pos;
  372|       |
  373|       |                    // 最適なラップ方向を探す
  374|       |                    // 展開図サイズは 横8, 縦6
  375|       |                    // 対角方向のショートカットも含めて探索することで、より自然な隣接点を見つける
  376|      0|                    let candidates = [
  377|      0|                        Vec2::new(8.0, 0.0),
  378|      0|                        Vec2::new(-8.0, 0.0),
  379|      0|                        Vec2::new(0.0, 6.0),
  380|      0|                        Vec2::new(0.0, -6.0),
  381|      0|                        Vec2::new(4.0, 3.0),
  382|      0|                        Vec2::new(-4.0, -3.0),
  383|      0|                        Vec2::new(4.0, -3.0),
  384|      0|                        Vec2::new(-4.0, 3.0),
  385|      0|                    ];
  386|       |
  387|      0|                    let mut best_wrap = Vec2::ZERO;
  388|      0|                    let mut min_len = f32::MAX;
  389|       |
  390|      0|                    for wrap in candidates {
  391|      0|                        let len = (diff - wrap).length();
  392|      0|                        if len < min_len {
  393|      0|                            min_len = len;
  394|      0|                            best_wrap = wrap;
  395|      0|                        }
  396|       |                    }
  397|       |
  398|      0|                    let wrap_vec_grid = best_wrap;
  399|       |
  400|      0|                    let progress = anim.eased_progress();
  401|       |
  402|       |                    // 1. 去るアニメーション (src -> dst_wrapped)
  403|       |                    // dst_wrapped = dst - wrap_vec
  404|      0|                    let dst_wrapped_grid = target_grid_pos - wrap_vec_grid;
  405|      0|                    let dst_wrapped_screen = to_screen(dst_wrapped_grid);
  406|      0|                    let src_screen = screen_pos; // 現在位置
  407|       |
  408|      0|                    let pos_out = src_screen + (dst_wrapped_screen - src_screen) * progress;
  409|       |
  410|       |                    // クリッピング領域（移動元の面内のみ表示）
  411|      0|                    let clip_grid_rect = get_face_grid_rect(i);
  412|       |                    // グリッド座標(中心)から矩形(左上〜右下)への変換補正
  413|      0|                    let clip_rect_src = Rect::from_min_max(
  414|      0|                        to_screen(clip_grid_rect.min) - Vec2::splat(grid_size * 0.5),
  415|      0|                        to_screen(clip_grid_rect.max) - Vec2::splat(grid_size * 0.5),
  416|       |                    );
  417|       |
  418|      0|                    let clipped_painter_src = painter.with_clip_rect(clip_rect_src);
  419|      0|                    draw_sticker(
  420|      0|                        &clipped_painter_src,
  421|      0|                        pos_out,
  422|      0|                        sticker_size,
  423|      0|                        sticker,
  424|      0|                        rotation,
  425|       |                        1.0,
  426|       |                    );
  427|       |
  428|       |                    // 2. 来るアニメーション (src_wrapped -> dst)
  429|       |                    // src_wrapped = src + wrap_vec
  430|      0|                    let src_wrapped_grid = grid_pos + wrap_vec_grid;
  431|      0|                    let src_wrapped_screen = to_screen(src_wrapped_grid);
  432|      0|                    let dst_screen = to_screen(target_grid_pos);
  433|       |
  434|      0|                    let pos_in = src_wrapped_screen + (dst_screen - src_wrapped_screen) * progress;
  435|       |
  436|       |                    // クリッピング領域（移動先の面内のみ表示）
  437|      0|                    let clip_grid_rect_dst = get_face_grid_rect(*target_idx);
  438|      0|                    let clip_rect_dst = Rect::from_min_max(
  439|      0|                        to_screen(clip_grid_rect_dst.min) - Vec2::splat(grid_size * 0.5),
  440|      0|                        to_screen(clip_grid_rect_dst.max) - Vec2::splat(grid_size * 0.5),
  441|       |                    );
  442|       |
  443|      0|                    let clipped_painter_dst = painter.with_clip_rect(clip_rect_dst);
  444|      0|                    draw_sticker(
  445|      0|                        &clipped_painter_dst,
  446|      0|                        pos_in,
  447|      0|                        sticker_size,
  448|      0|                        sticker,
  449|      0|                        rotation,
  450|       |                        1.0,
  451|       |                    );
  452|       |
  453|      0|                    drawn = true;
  454|       |                }
  455|      0|            }
  456|      0|        }
  457|       |
  458|      0|        if !drawn {
  459|      0|            draw_sticker(painter, screen_pos, sticker_size, sticker, rotation, 1.0);
  460|      0|        }
  461|       |    }
  462|       |
  463|      0|    if let Some(anim) = animation {
  464|      0|        let text = format!(
  465|      0|            "動作: {} ({:.0}%)",
  466|      0|            anim.current_move,
  467|      0|            anim.progress * 100.0
  468|      0|        );
  469|      0|        painter.text(
  470|      0|            Pos2::new(rect.left() + 10.0, rect.bottom() - 30.0),
  471|      0|            egui::Align2::LEFT_BOTTOM,
  472|      0|            text,
  473|      0|            egui::FontId::proportional(16.0),
  474|      0|            Color32::BLACK,
  475|      0|        );
  476|      0|    }
  477|      0|}
  478|       |
  479|       |/// インデックスに対応する面全体のグリッド領域を取得
  480|      0|fn get_face_grid_rect(index: usize) -> Rect {
  481|      0|    let (min_col, min_row) = match index {
  482|      0|        0..=3 => (2.0, 0.0),   // U
  483|      0|        4..=7 => (2.0, 4.0),   // D
  484|      0|        8..=11 => (0.0, 2.0),  // L
  485|      0|        12..=15 => (4.0, 2.0), // R
  486|      0|        16..=19 => (2.0, 2.0), // F
  487|      0|        20..=23 => (6.0, 2.0), // B
  488|      0|        _ => (0.0, 0.0),
  489|       |    };
  490|       |    // 2x2なのでサイズは2.0x2.0
  491|      0|    Rect::from_min_size(Pos2::new(min_col, min_row), Vec2::new(2.0, 2.0))
  492|      0|}

/Users/katoy/github/study-rust/2x2/src/gui/renderer_3d.rs:
    1|       |use crate::cube::{Color, Cube, Move};
    2|       |use crate::gui::app::AnimationState;
    3|       |use egui::{Color32, Pos2, Rect, Stroke};
    4|       |use glam::{Mat4, Vec3};
    5|       |use std::f32::consts::PI;
    6|       |
    7|       |/// 3D描画の設定
    8|       |pub struct View3D {
    9|       |    pub yaw: f32,
   10|       |    pub pitch: f32,
   11|       |    pub scale: f32,
   12|       |}
   13|       |
   14|       |impl Default for View3D {
   15|      0|    fn default() -> Self {
   16|      0|        Self {
   17|      0|            yaw: PI / 4.0,
   18|      0|            pitch: PI / 6.0,
   19|      0|            scale: 1.0,
   20|      0|        }
   21|      0|    }
   22|       |}
   23|       |
   24|       |/// ステッカーの3D情報
   25|       |#[derive(Clone, Copy)]
   26|       |struct Sticker3D {
   27|       |    index: usize,
   28|       |    center: Vec3,
   29|       |    normal: Vec3,
   30|       |    u_vec: Vec3, // ステッカーの「右」方向
   31|       |    v_vec: Vec3, // ステッカーの「下」方向
   32|       |}
   33|       |
   34|       |/// 色変換
   35|      0|fn color_to_color32(color: Color) -> Color32 {
   36|      0|    match color {
   37|      0|        Color::White => Color32::from_rgb(255, 255, 255),
   38|      0|        Color::Yellow => Color32::from_rgb(255, 255, 0),
   39|      0|        Color::Green => Color32::from_rgb(0, 200, 0),
   40|      0|        Color::Blue => Color32::from_rgb(0, 100, 255),
   41|      0|        Color::Red => Color32::from_rgb(255, 50, 50),
   42|      0|        Color::Orange => Color32::from_rgb(255, 165, 0),
   43|       |    }
   44|      0|}
   45|       |
   46|       |/// 描画用の頂点データ
   47|       |struct DrawFace {
   48|       |    z_score: f32,
   49|       |    points: Vec<Pos2>,
   50|       |    color: Color32,
   51|       |    sticker_index: usize,
   52|       |    center_2d: Pos2,
   53|       |    u_vec_2d: egui::Vec2,
   54|       |    v_vec_2d: egui::Vec2,
   55|       |}
   56|       |
   57|       |/// 3D投影ヘルパー関数
   58|      0|fn project_point(
   59|      0|    p: Vec3,
   60|      0|    model_mat: &Mat4,
   61|      0|    view_mat: &Mat4,
   62|      0|    scale: f32,
   63|      0|    screen_center: Pos2,
   64|      0|) -> Pos2 {
   65|      0|    let world = model_mat.transform_point3(p);
   66|      0|    let view = view_mat.transform_point3(world);
   67|      0|    let distance = 5.0 - view.z;
   68|      0|    let perspective = 5.0 / distance;
   69|      0|    Pos2::new(
   70|      0|        screen_center.x + view.x * scale * perspective,
   71|      0|        screen_center.y - view.y * scale * perspective,
   72|       |    )
   73|      0|}
   74|       |
   75|       |/// ステッカーの初期3D配置を生成
   76|      0|fn get_initial_stickers() -> Vec<Sticker3D> {
   77|      0|    let mut stickers = Vec::with_capacity(24);
   78|      0|    let size = 0.45; // ステッカーのサイズ（少し小さくして境界を作る）
   79|       |
   80|       |    // ヘルパー: 面ごとの生成
   81|       |    // U (Up): y = +1, index 0-3
   82|      0|    for i in 0..4 {
   83|      0|        let col = (i % 2) as f32; // 0, 1
   84|      0|        let row = (i / 2) as f32; // 0, 1
   85|      0|        let x = (col - 0.5) * 1.0;
   86|      0|        let z = (row - 0.5) * 1.0;
   87|      0|        stickers.push(Sticker3D {
   88|      0|            index: i,
   89|      0|            center: Vec3::new(x, 1.0, z),
   90|      0|            normal: Vec3::Y,
   91|      0|            u_vec: Vec3::X * size,
   92|      0|            v_vec: Vec3::Z * size,
   93|      0|        });
   94|      0|    }
   95|       |
   96|       |    // D (Down): y = -1, index 4-7
   97|      0|    for i in 0..4 {
   98|      0|        let col = (i % 2) as f32;
   99|      0|        let row = (i / 2) as f32;
  100|      0|        let x = (col - 0.5) * 1.0;
  101|      0|        let z = (1.0 - row - 0.5) * 1.0;
  102|      0|        stickers.push(Sticker3D {
  103|      0|            index: 4 + i,
  104|      0|            center: Vec3::new(x, -1.0, z),
  105|      0|            normal: -Vec3::Y,
  106|      0|            u_vec: Vec3::X * size,
  107|      0|            v_vec: -Vec3::Z * size,
  108|      0|        });
  109|      0|    }
  110|       |
  111|       |    // L (Left): x = -1, index 8-11
  112|      0|    for i in 0..4 {
  113|      0|        let col = (i % 2) as f32;
  114|      0|        let row = (i / 2) as f32;
  115|      0|        let z = (col - 0.5) * 1.0;
  116|      0|        let y = (1.0 - row - 0.5) * 1.0;
  117|      0|        stickers.push(Sticker3D {
  118|      0|            index: 8 + i,
  119|      0|            center: Vec3::new(-1.0, y, z),
  120|      0|            normal: -Vec3::X,
  121|      0|            u_vec: -Vec3::Z * size,
  122|      0|            v_vec: -Vec3::Y * size,
  123|      0|        });
  124|      0|    }
  125|       |
  126|       |    // R (Right): x = +1, index 12-15
  127|      0|    for i in 0..4 {
  128|      0|        let col = (i % 2) as f32;
  129|      0|        let row = (i / 2) as f32;
  130|      0|        let z = (1.0 - col - 0.5) * 1.0;
  131|      0|        let y = (1.0 - row - 0.5) * 1.0;
  132|      0|        stickers.push(Sticker3D {
  133|      0|            index: 12 + i,
  134|      0|            center: Vec3::new(1.0, y, z),
  135|      0|            normal: Vec3::X,
  136|      0|            u_vec: Vec3::Z * size,
  137|      0|            v_vec: -Vec3::Y * size,
  138|      0|        });
  139|      0|    }
  140|       |
  141|       |    // F (Front): z = +1, index 16-19
  142|      0|    for i in 0..4 {
  143|      0|        let col = (i % 2) as f32;
  144|      0|        let row = (i / 2) as f32;
  145|      0|        let x = (col - 0.5) * 1.0;
  146|      0|        let y = (1.0 - row - 0.5) * 1.0;
  147|      0|        stickers.push(Sticker3D {
  148|      0|            index: 16 + i,
  149|      0|            center: Vec3::new(x, y, 1.0),
  150|      0|            normal: Vec3::Z,
  151|      0|            u_vec: Vec3::X * size,
  152|      0|            v_vec: -Vec3::Y * size,
  153|      0|        });
  154|      0|    }
  155|       |
  156|       |    // B (Back): z = -1, index 20-23
  157|      0|    for i in 0..4 {
  158|      0|        let col = (i % 2) as f32;
  159|      0|        let row = (i / 2) as f32;
  160|      0|        let x = (1.0 - col - 0.5) * 1.0;
  161|      0|        let y = (1.0 - row - 0.5) * 1.0;
  162|      0|        stickers.push(Sticker3D {
  163|      0|            index: 20 + i,
  164|      0|            center: Vec3::new(x, y, -1.0),
  165|      0|            normal: -Vec3::Z,
  166|      0|            u_vec: -Vec3::X * size,
  167|      0|            v_vec: -Vec3::Y * size,
  168|      0|        });
  169|      0|    }
  170|       |
  171|      0|    stickers
  172|      0|}
  173|       |
  174|       |/// 3D空間で矢印を描画
  175|      0|fn draw_arrow_3d(painter: &egui::Painter, center: Pos2, target: Pos2, color: Color32, width: f32) {
  176|      0|    let direction = target - center;
  177|      0|    let arrow_length = direction.length();
  178|      0|    if arrow_length < 0.1 {
  179|      0|        return; // 矢印が極端に小さい場合はスキップ
  180|      0|    }
  181|       |
  182|      0|    let dir_normalized = direction.normalized();
  183|      0|    let arrow_end = center + dir_normalized * arrow_length;
  184|       |
  185|       |    // 矢印の本体
  186|      0|    painter.line_segment([center, arrow_end], Stroke::new(width, color));
  187|       |
  188|       |    // 矢印の先端（三角形）
  189|      0|    let arrow_head_size = arrow_length * 0.6;
  190|      0|    let perpendicular = egui::vec2(-dir_normalized.y, dir_normalized.x);
  191|       |
  192|      0|    let tip = arrow_end;
  193|      0|    let left = arrow_end - dir_normalized * arrow_head_size + perpendicular * arrow_head_size * 0.5;
  194|      0|    let right =
  195|      0|        arrow_end - dir_normalized * arrow_head_size - perpendicular * arrow_head_size * 0.5;
  196|       |
  197|      0|    painter.add(egui::Shape::convex_polygon(
  198|      0|        vec![tip, left, right],
  199|      0|        color,
  200|       |        Stroke::NONE,
  201|       |    ));
  202|      0|}
  203|       |
  204|       |/// 3D描画関数
  205|      0|pub fn draw_cube_3d(
  206|      0|    ui: &mut egui::Ui,
  207|      0|    rect: Rect,
  208|      0|    cube: &Cube,
  209|      0|    animation: Option<&AnimationState>,
  210|      0|    view: &View3D,
  211|      0|) {
  212|      0|    let painter = ui.painter();
  213|       |
  214|       |    // カメラ設定
  215|      0|    let center = rect.center();
  216|      0|    let min_dim = rect.width().min(rect.height());
  217|      0|    let scale = min_dim * 0.3 * view.scale;
  218|       |
  219|       |    // ビュー行列 (Orbit camera)
  220|      0|    let rotation = Mat4::from_rotation_x(view.pitch) * Mat4::from_rotation_y(view.yaw);
  221|      0|    let view_mat = rotation; // カメラ位置は固定、オブジェクトを回転させるイメージ
  222|       |
  223|       |    // アニメーション情報取得
  224|      0|    let (anim_axis, anim_layer, anim_angle) = if let Some(anim) = animation {
  225|      0|        let progress = anim.eased_progress();
  226|      0|        let angle = progress * 90.0f32.to_radians();
  227|      0|        let angle = match anim.current_move {
  228|      0|            Move::R | Move::L | Move::U | Move::D | Move::F | Move::B => angle,
  229|      0|            _ => -angle, // Prime moves
  230|       |        };
  231|       |
  232|      0|        match anim.current_move {
  233|      0|            Move::R | Move::Rp => (Vec3::X, 1, angle), // Right is x > 0
  234|      0|            Move::L | Move::Lp => (Vec3::X, -1, angle), // Left is x < 0
  235|      0|            Move::U | Move::Up => (Vec3::Y, 1, angle), // Up is y > 0
  236|      0|            Move::D | Move::Dp => (Vec3::Y, -1, angle), // Down is y < 0
  237|      0|            Move::F | Move::Fp => (Vec3::Z, 1, angle), // Front is z > 0
  238|      0|            Move::B | Move::Bp => (Vec3::Z, -1, angle), // Back is z < 0
  239|       |        }
  240|       |    } else {
  241|      0|        (Vec3::X, 0, 0.0)
  242|       |    };
  243|       |
  244|      0|    let initial_stickers = get_initial_stickers();
  245|      0|    let mut draw_faces = Vec::new();
  246|       |
  247|      0|    for sticker_def in initial_stickers {
  248|       |        // 現在のステッカーの状態（色）を取得
  249|      0|        let sticker_data = cube.get_sticker(sticker_def.index);
  250|      0|        let color = color_to_color32(sticker_data.color);
  251|       |
  252|       |        // アニメーション回転の適用
  253|      0|        let mut model_mat = Mat4::IDENTITY;
  254|       |
  255|      0|        if animation.is_some() {
  256|      0|            let is_affected = match anim_axis {
  257|      0|                v if v == Vec3::X => {
  258|      0|                    (sticker_def.center.x > 0.0 && anim_layer == 1)
  259|      0|                        || (sticker_def.center.x < 0.0 && anim_layer == -1)
  260|       |                }
  261|      0|                v if v == Vec3::Y => {
  262|      0|                    (sticker_def.center.y > 0.0 && anim_layer == 1)
  263|      0|                        || (sticker_def.center.y < 0.0 && anim_layer == -1)
  264|       |                }
  265|      0|                v if v == Vec3::Z => {
  266|      0|                    (sticker_def.center.z > 0.0 && anim_layer == 1)
  267|      0|                        || (sticker_def.center.z < 0.0 && anim_layer == -1)
  268|       |                }
  269|      0|                _ => false,
  270|       |            };
  271|       |
  272|      0|            if is_affected {
  273|      0|                model_mat = Mat4::from_axis_angle(anim_axis, anim_angle);
  274|      0|            }
  275|      0|        }
  276|       |
  277|       |        // 頂点の計算
  278|      0|        let corners = [
  279|      0|            sticker_def.center - sticker_def.u_vec - sticker_def.v_vec,
  280|      0|            sticker_def.center + sticker_def.u_vec - sticker_def.v_vec,
  281|      0|            sticker_def.center + sticker_def.u_vec + sticker_def.v_vec,
  282|      0|            sticker_def.center - sticker_def.u_vec + sticker_def.v_vec,
  283|      0|        ];
  284|       |
  285|      0|        let mut transformed_corners = Vec::with_capacity(4);
  286|      0|        let mut avg_z = 0.0;
  287|       |
  288|       |        // 法線の変換
  289|      0|        let normal_transformed =
  290|      0|            view_mat.transform_vector3(model_mat.transform_vector3(sticker_def.normal));
  291|       |
  292|       |        // バックフェイスカリング（簡易）
  293|       |        // view_matで変換した結果、Zが正ならカメラに向いている
  294|      0|        if normal_transformed.z > 0.2 {
  295|       |            // 少し余裕を持たせる
  296|      0|            for p in corners {
  297|      0|                let p_world = model_mat.transform_point3(p);
  298|      0|                let p_view = view_mat.transform_point3(p_world);
  299|      0|
  300|      0|                // 透視投影っぽい効果 (Zに応じてスケール)
  301|      0|                let distance = 5.0 - p_view.z; // カメラ距離
  302|      0|                let perspective = 5.0 / distance;
  303|      0|
  304|      0|                let x = center.x + p_view.x * scale * perspective;
  305|      0|                let y = center.y - p_view.y * scale * perspective; // Y-up to Y-down screen
  306|      0|
  307|      0|                transformed_corners.push(Pos2::new(x, y));
  308|      0|                avg_z += p_view.z;
  309|      0|            }
  310|      0|            avg_z /= 4.0;
  311|       |
  312|       |            // ステッカーの中心を計算（2D投影後）
  313|      0|            let center_2d = project_point(sticker_def.center, &model_mat, &view_mat, scale, center);
  314|       |
  315|       |            // U方向とV方向のベクトルを計算（2D投影後）
  316|       |            // ベクトルの先端を計算してから差分を取る
  317|      0|            let u_end_2d = project_point(
  318|      0|                sticker_def.center + sticker_def.u_vec * 0.6,
  319|      0|                &model_mat,
  320|      0|                &view_mat,
  321|      0|                scale,
  322|      0|                center,
  323|       |            );
  324|      0|            let v_end_2d = project_point(
  325|      0|                sticker_def.center + sticker_def.v_vec * 0.6,
  326|      0|                &model_mat,
  327|      0|                &view_mat,
  328|      0|                scale,
  329|      0|                center,
  330|       |            );
  331|       |
  332|      0|            let u_vec_2d = u_end_2d - center_2d;
  333|      0|            let v_vec_2d = v_end_2d - center_2d;
  334|       |
  335|      0|            draw_faces.push(DrawFace {
  336|      0|                z_score: avg_z,
  337|      0|                points: transformed_corners,
  338|      0|                color,
  339|      0|                sticker_index: sticker_def.index,
  340|      0|                center_2d,
  341|      0|                u_vec_2d,
  342|      0|                v_vec_2d,
  343|      0|            });
  344|      0|        }
  345|       |    }
  346|       |
  347|       |    // Zソート（奥から手前へ）
  348|      0|    draw_faces.sort_by(|a, b| {
  349|      0|        a.z_score
  350|      0|            .partial_cmp(&b.z_score)
  351|      0|            .unwrap_or(std::cmp::Ordering::Equal)
  352|      0|    });
  353|       |
  354|       |    // 描画
  355|      0|    for face in draw_faces {
  356|      0|        if face.points.len() >= 3 {
  357|      0|            painter.add(egui::Shape::convex_polygon(
  358|      0|                face.points.clone(),
  359|      0|                face.color,
  360|      0|                Stroke::new(1.0, Color32::BLACK), // 枠線
  361|       |            ));
  362|       |
  363|       |            // ステッカーの向きを示す矢印を描画
  364|      0|            let sticker_data = cube.get_sticker(face.sticker_index);
  365|       |            // orientationに応じて方向を決定
  366|       |            // 0: 上 (-v), 1: 右 (+u), 2: 下 (+v), 3: 左 (-u)
  367|       |            // ※ rotate_cwで+1されるため
  368|      0|            let arrow_vec = match sticker_data.orientation {
  369|      0|                0 => -face.v_vec_2d,
  370|      0|                1 => face.u_vec_2d,
  371|      0|                2 => face.v_vec_2d,
  372|      0|                3 => -face.u_vec_2d,
  373|      0|                _ => egui::Vec2::ZERO,
  374|       |            };
  375|       |
  376|       |            // 黒い矢印のみ描画（太く、大きく）
  377|      0|            draw_arrow_3d(
  378|      0|                painter,
  379|      0|                face.center_2d,
  380|      0|                face.center_2d + arrow_vec,
  381|       |                Color32::BLACK,
  382|       |                6.0,
  383|       |            );
  384|      0|        }
  385|       |    }
  386|      0|}

/Users/katoy/github/study-rust/2x2/src/main.rs:
    1|       |use rubiks_cube_2x2::gui::CubeApp;
    2|       |
    3|      0|fn main() -> eframe::Result<()> {
    4|      0|    let options = eframe::NativeOptions {
    5|      0|        viewport: egui::ViewportBuilder::default()
    6|      0|            .with_inner_size([1000.0, 600.0])
    7|      0|            .with_title("2x2 ルービックキューブ"),
    8|      0|        ..Default::default()
    9|      0|    };
   10|       |
   11|      0|    eframe::run_native(
   12|      0|        "2x2 ルービックキューブ",
   13|      0|        options,
   14|      0|        Box::new(|cc| Ok(Box::new(CubeApp::new(cc)))),
   15|       |    )
   16|      0|}

/Users/katoy/github/study-rust/2x2/src/solver.rs:
    1|       |use crate::cube::{Cube, Move};
    2|       |use std::collections::{HashMap, VecDeque};
    3|       |
    4|       |/// ソルバーの結果
    5|       |#[derive(Debug, Clone)]
    6|       |pub struct Solution {
    7|       |    pub moves: Vec<Move>,
    8|       |    pub found: bool,
    9|       |}
   10|       |
   11|       |/// 全24通りの向きの完成状態を生成する
   12|     11|fn generate_all_solved_states() -> Vec<Cube> {
   13|     11|    let base = Cube::new();
   14|     11|    let mut states = Vec::new();
   15|     11|    let mut queue = VecDeque::new();
   16|     11|    let mut visited = HashMap::new();
   17|       |
   18|       |    // 初期状態
   19|     11|    let base_norm = base.normalized();
   20|     11|    queue.push_back(base.clone());
   21|     11|    visited.insert(base_norm, true);
   22|     11|    states.push(base);
   23|       |
   24|       |    // 全体回転操作の組み合わせ
   25|       |    // Y軸回転: U + D'
   26|       |    // X軸回転: R + L'
   27|       |    // Z軸回転: F + B'
   28|     11|    let rotations = vec![
   29|     11|        vec![Move::U, Move::Dp],
   30|     11|        vec![Move::R, Move::Lp],
   31|     11|        vec![Move::F, Move::Bp],
   32|       |    ];
   33|       |
   34|       |    // 24通りしかないので、ループ回数は高が知れているが、念のため上限を設ける
   35|     11|    let mut count = 0;
   36|    275|    while let Some(current) = queue.pop_front() {
                                 ^264
   37|    264|        if count > 100 {
   38|      0|            break;
   39|    264|        }
   40|    264|        count += 1;
   41|       |
   42|  1.05k|        for rot_moves in &rotations {
                          ^792
   43|    792|            let mut next = current.clone();
   44|  2.37k|            for &mv in rot_moves {
                               ^1.58k
   45|  1.58k|                next.apply_move(mv);
   46|  1.58k|            }
   47|       |
   48|    792|            let next_norm = next.normalized();
   49|    792|            if let std::collections::hash_map::Entry::Vacant(e) = visited.entry(next_norm) {
                                                                           ^253
   50|    253|                e.insert(true);
   51|    253|                states.push(next.clone());
   52|    253|                queue.push_back(next);
   53|    539|            }
   54|       |        }
   55|       |    }
   56|       |
   57|     11|    states
   58|     11|}
   59|       |
   60|       |/// 双方向BFSを使用して最短解を探索
   61|     17|pub fn solve(start_cube: &Cube, max_depth: usize) -> Solution {
   62|     17|    println!("BFS探索開始: 最大深度={}", max_depth);
   63|       |
   64|       |    // 既に解けている場合（正規化して比較が必要だが、is_solved()は色しか見ないのでOK）
   65|     17|    if start_cube.is_solved() {
   66|      6|        println!("既に完成しています");
   67|      6|        return Solution {
   68|      6|            moves: vec![],
   69|      6|            found: true,
   70|      6|        };
   71|     11|    }
   72|       |
   73|     11|    let forward_depth = max_depth.div_ceil(2);
   74|     11|    let backward_depth = max_depth - forward_depth;
   75|     11|    println!(
   76|     11|        "順方向深度: {}, 逆方向深度: {}",
   77|       |        forward_depth, backward_depth
   78|       |    );
   79|       |
   80|       |    // --- 順方向探索 ---
   81|     11|    let mut forward_dist: HashMap<Cube, Vec<Move>> = HashMap::new();
   82|     11|    let mut forward_queue: VecDeque<Cube> = VecDeque::new();
   83|       |
   84|     11|    let start_norm = start_cube.normalized();
   85|     11|    forward_dist.insert(start_norm.clone(), vec![]);
   86|     11|    forward_queue.push_back(start_norm);
   87|       |
   88|       |    // 順方向BFS実行
   89|     11|    let mut current_depth = 0;
   90|     72|    while current_depth < forward_depth {
   91|     61|        let level_size = forward_queue.len();
   92|     61|        if level_size == 0 {
   93|      0|            break;
   94|     61|        }
   95|       |
   96|     61|        for _ in 0..level_size {
   97|  1.03M|            let curr = forward_queue.pop_front().unwrap();
   98|  1.03M|            let curr_path = forward_dist.get(&curr).unwrap().clone();
   99|       |
  100|  12.4M|            for mv in Move::all_moves() {
                                    ^1.03M
  101|       |                // 枝刈り: 直前の逆操作は行わない
  102|  12.4M|                if let Some(last_move) = curr_path.last() {
                                          ^12.4M
  103|  12.4M|                    if *last_move == mv.inverse() {
  104|  1.03M|                        continue;
  105|  11.4M|                    }
  106|    132|                }
  107|       |
  108|  11.4M|                let mut next = curr.clone();
  109|  11.4M|                next.apply_move(mv);
  110|  11.4M|                let next_norm = next.normalized();
  111|       |
  112|  11.4M|                if !forward_dist.contains_key(&next_norm) {
  113|  9.67M|                    let mut next_path = curr_path.clone();
  114|  9.67M|                    next_path.push(mv);
  115|  9.67M|                    forward_dist.insert(next_norm.clone(), next_path);
  116|  9.67M|                    forward_queue.push_back(next_norm);
  117|  9.67M|                }
                              ^1.76M
  118|       |            }
  119|       |        }
  120|     61|        current_depth += 1;
  121|       |    }
  122|       |
  123|       |    // --- 逆方向探索 ---
  124|     11|    let mut backward_queue: VecDeque<(Cube, Vec<Move>)> = VecDeque::new();
  125|     11|    let mut backward_visited: HashMap<Cube, ()> = HashMap::new();
  126|       |
  127|       |    // 全24通りの完成状態を初期状態とする
  128|     11|    let all_solved = generate_all_solved_states();
  129|    275|    for solved in all_solved {
                      ^264
  130|    264|        let s_norm = solved.normalized();
  131|    264|        if !backward_visited.contains_key(&s_norm) {
  132|    264|            backward_visited.insert(s_norm.clone(), ());
  133|    264|            backward_queue.push_back((s_norm, vec![]));
  134|    264|        }
                      ^0
  135|       |    }
  136|       |
  137|       |    // 逆方向BFS実行
  138|     11|    let mut current_depth = 0;
  139|     16|    while !backward_queue.is_empty() && current_depth <= backward_depth {
                                                      ^15
  140|     15|        let level_size = backward_queue.len();
  141|       |
  142|     15|        for _ in 0..level_size {
  143|  1.28k|            let (curr, curr_path_rev) = backward_queue.pop_front().unwrap();
  144|       |
  145|       |            // 衝突判定: 順方向探索の結果とマッチするか
  146|  1.28k|            if let Some(fwd_path) = forward_dist.get(&curr) {
                                      ^10
  147|       |                // 解を発見
  148|     10|                let mut full_path = fwd_path.clone();
  149|       |                // 逆方向パスを反転して追加
  150|     10|                for mv in curr_path_rev.iter().rev() {
                                  ^4
  151|      4|                    full_path.push(mv.inverse());
  152|      4|                }
  153|     10|                println!("解を発見: {} 手", full_path.len());
  154|     10|                return Solution {
  155|     10|                    moves: full_path,
  156|     10|                    found: true,
  157|     10|                };
  158|  1.27k|            }
  159|       |
  160|  1.27k|            if current_depth == backward_depth {
  161|     24|                continue;
  162|  1.24k|            }
  163|       |
  164|  14.9k|            for mv in Move::all_moves() {
                                    ^1.24k
  165|       |                // 枝刈り
  166|  14.9k|                if let Some(last_move) = curr_path_rev.last() {
                                          ^14.3k
  167|  14.3k|                    if *last_move == mv.inverse() {
  168|  1.19k|                        continue;
  169|  13.1k|                    }
  170|    576|                }
  171|       |
  172|  13.7k|                let mut prev = curr.clone();
  173|  13.7k|                prev.apply_move(mv);
  174|  13.7k|                let prev_norm = prev.normalized();
  175|       |
  176|  13.7k|                if !backward_visited.contains_key(&prev_norm) {
  177|  10.1k|                    backward_visited.insert(prev_norm.clone(), ());
  178|  10.1k|                    let mut next_path = curr_path_rev.clone();
  179|  10.1k|                    next_path.push(mv);
  180|  10.1k|                    backward_queue.push_back((prev_norm, next_path));
  181|  10.1k|                }
                              ^3.63k
  182|       |            }
  183|       |        }
  184|      5|        current_depth += 1;
  185|       |    }
  186|       |
  187|      1|    println!("解が見つかりませんでした（探索深度: {}）", max_depth);
  188|      1|    Solution {
  189|      1|        moves: vec![],
  190|      1|        found: false,
  191|      1|    }
  192|     17|}

